//#region node_modules/culori/src/rgb/parseNumber.js
var parseNumber = (color, len) => {
	if (typeof color !== "number") return;
	if (len === 3) return {
		mode: "rgb",
		r: (color >> 8 & 15 | color >> 4 & 240) / 255,
		g: (color >> 4 & 15 | color & 240) / 255,
		b: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 4) return {
		mode: "rgb",
		r: (color >> 12 & 15 | color >> 8 & 240) / 255,
		g: (color >> 8 & 15 | color >> 4 & 240) / 255,
		b: (color >> 4 & 15 | color & 240) / 255,
		alpha: (color & 15 | color << 4 & 240) / 255
	};
	if (len === 6) return {
		mode: "rgb",
		r: (color >> 16 & 255) / 255,
		g: (color >> 8 & 255) / 255,
		b: (color & 255) / 255
	};
	if (len === 8) return {
		mode: "rgb",
		r: (color >> 24 & 255) / 255,
		g: (color >> 16 & 255) / 255,
		b: (color >> 8 & 255) / 255,
		alpha: (color & 255) / 255
	};
};
var parseNumber_default = parseNumber;

//#endregion
//#region node_modules/culori/src/colors/named.js
var named = {
	aliceblue: 15792383,
	antiquewhite: 16444375,
	aqua: 65535,
	aquamarine: 8388564,
	azure: 15794175,
	beige: 16119260,
	bisque: 16770244,
	black: 0,
	blanchedalmond: 16772045,
	blue: 255,
	blueviolet: 9055202,
	brown: 10824234,
	burlywood: 14596231,
	cadetblue: 6266528,
	chartreuse: 8388352,
	chocolate: 13789470,
	coral: 16744272,
	cornflowerblue: 6591981,
	cornsilk: 16775388,
	crimson: 14423100,
	cyan: 65535,
	darkblue: 139,
	darkcyan: 35723,
	darkgoldenrod: 12092939,
	darkgray: 11119017,
	darkgreen: 25600,
	darkgrey: 11119017,
	darkkhaki: 12433259,
	darkmagenta: 9109643,
	darkolivegreen: 5597999,
	darkorange: 16747520,
	darkorchid: 10040012,
	darkred: 9109504,
	darksalmon: 15308410,
	darkseagreen: 9419919,
	darkslateblue: 4734347,
	darkslategray: 3100495,
	darkslategrey: 3100495,
	darkturquoise: 52945,
	darkviolet: 9699539,
	deeppink: 16716947,
	deepskyblue: 49151,
	dimgray: 6908265,
	dimgrey: 6908265,
	dodgerblue: 2003199,
	firebrick: 11674146,
	floralwhite: 16775920,
	forestgreen: 2263842,
	fuchsia: 16711935,
	gainsboro: 14474460,
	ghostwhite: 16316671,
	gold: 16766720,
	goldenrod: 14329120,
	gray: 8421504,
	green: 32768,
	greenyellow: 11403055,
	grey: 8421504,
	honeydew: 15794160,
	hotpink: 16738740,
	indianred: 13458524,
	indigo: 4915330,
	ivory: 16777200,
	khaki: 15787660,
	lavender: 15132410,
	lavenderblush: 16773365,
	lawngreen: 8190976,
	lemonchiffon: 16775885,
	lightblue: 11393254,
	lightcoral: 15761536,
	lightcyan: 14745599,
	lightgoldenrodyellow: 16448210,
	lightgray: 13882323,
	lightgreen: 9498256,
	lightgrey: 13882323,
	lightpink: 16758465,
	lightsalmon: 16752762,
	lightseagreen: 2142890,
	lightskyblue: 8900346,
	lightslategray: 7833753,
	lightslategrey: 7833753,
	lightsteelblue: 11584734,
	lightyellow: 16777184,
	lime: 65280,
	limegreen: 3329330,
	linen: 16445670,
	magenta: 16711935,
	maroon: 8388608,
	mediumaquamarine: 6737322,
	mediumblue: 205,
	mediumorchid: 12211667,
	mediumpurple: 9662683,
	mediumseagreen: 3978097,
	mediumslateblue: 8087790,
	mediumspringgreen: 64154,
	mediumturquoise: 4772300,
	mediumvioletred: 13047173,
	midnightblue: 1644912,
	mintcream: 16121850,
	mistyrose: 16770273,
	moccasin: 16770229,
	navajowhite: 16768685,
	navy: 128,
	oldlace: 16643558,
	olive: 8421376,
	olivedrab: 7048739,
	orange: 16753920,
	orangered: 16729344,
	orchid: 14315734,
	palegoldenrod: 15657130,
	palegreen: 10025880,
	paleturquoise: 11529966,
	palevioletred: 14381203,
	papayawhip: 16773077,
	peachpuff: 16767673,
	peru: 13468991,
	pink: 16761035,
	plum: 14524637,
	powderblue: 11591910,
	purple: 8388736,
	rebeccapurple: 6697881,
	red: 16711680,
	rosybrown: 12357519,
	royalblue: 4286945,
	saddlebrown: 9127187,
	salmon: 16416882,
	sandybrown: 16032864,
	seagreen: 3050327,
	seashell: 16774638,
	sienna: 10506797,
	silver: 12632256,
	skyblue: 8900331,
	slateblue: 6970061,
	slategray: 7372944,
	slategrey: 7372944,
	snow: 16775930,
	springgreen: 65407,
	steelblue: 4620980,
	tan: 13808780,
	teal: 32896,
	thistle: 14204888,
	tomato: 16737095,
	turquoise: 4251856,
	violet: 15631086,
	wheat: 16113331,
	white: 16777215,
	whitesmoke: 16119285,
	yellow: 16776960,
	yellowgreen: 10145074
};
var named_default = named;

//#endregion
//#region node_modules/culori/src/rgb/parseNamed.js
var parseNamed = (color) => {
	return parseNumber_default(named_default[color.toLowerCase()], 6);
};
var parseNamed_default = parseNamed;

//#endregion
//#region node_modules/culori/src/rgb/parseHex.js
var hex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
var parseHex = (color) => {
	let match;
	return (match = color.match(hex)) ? parseNumber_default(parseInt(match[1], 16), match[1].length) : void 0;
};
var parseHex_default = parseHex;

//#endregion
//#region node_modules/culori/src/util/regex.js
const num$1 = "([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)";
const num_none = `(?:${num$1}|none)`;
const per = `${num$1}%`;
const per_none = `(?:${num$1}%|none)`;
const num_per = `(?:${num$1}%|${num$1})`;
const num_per_none = `(?:${num$1}%|${num$1}|none)`;
const hue = `(?:${num$1}(deg|grad|rad|turn)|${num$1})`;
const hue_none = `(?:${num$1}(deg|grad|rad|turn)|${num$1}|none)`;
const c = `\\s*,\\s*`;
const rx_num_per_none = /* @__PURE__ */ new RegExp("^" + num_per_none + "$");

//#endregion
//#region node_modules/culori/src/rgb/parseRgbLegacy.js
var rgb_num_old = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${num$1}${c}${num$1}${c}${num$1}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
var rgb_per_old = /* @__PURE__ */ new RegExp(`^rgba?\\(\\s*${per}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
var parseRgbLegacy = (color) => {
	let res = { mode: "rgb" };
	let match;
	if (match = color.match(rgb_num_old)) {
		if (match[1] !== void 0) res.r = match[1] / 255;
		if (match[2] !== void 0) res.g = match[2] / 255;
		if (match[3] !== void 0) res.b = match[3] / 255;
	} else if (match = color.match(rgb_per_old)) {
		if (match[1] !== void 0) res.r = match[1] / 100;
		if (match[2] !== void 0) res.g = match[2] / 100;
		if (match[3] !== void 0) res.b = match[3] / 100;
	} else return;
	if (match[4] !== void 0) res.alpha = Math.max(0, Math.min(1, match[4] / 100));
	else if (match[5] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[5]));
	return res;
};
var parseRgbLegacy_default = parseRgbLegacy;

//#endregion
//#region node_modules/culori/src/_prepare.js
var prepare = (color, mode) => color === void 0 ? void 0 : typeof color !== "object" ? parse_default(color) : color.mode !== void 0 ? color : mode ? {
	...color,
	mode
} : void 0;
var _prepare_default = prepare;

//#endregion
//#region node_modules/culori/src/converter.js
var converter = (target_mode = "rgb") => (color) => (color = _prepare_default(color, target_mode)) !== void 0 ? color.mode === target_mode ? color : converters[color.mode][target_mode] ? converters[color.mode][target_mode](color) : target_mode === "rgb" ? converters[color.mode].rgb(color) : converters.rgb[target_mode](converters[color.mode].rgb(color)) : void 0;
var converter_default = converter;

//#endregion
//#region node_modules/culori/src/modes.js
var converters = {};
var modes = {};
var parsers = [];
var colorProfiles = {};
var identity = (v) => v;
var useMode = (definition$28) => {
	converters[definition$28.mode] = {
		...converters[definition$28.mode],
		...definition$28.toMode
	};
	Object.keys(definition$28.fromMode || {}).forEach((k$3) => {
		if (!converters[k$3]) converters[k$3] = {};
		converters[k$3][definition$28.mode] = definition$28.fromMode[k$3];
	});
	if (!definition$28.ranges) definition$28.ranges = {};
	if (!definition$28.difference) definition$28.difference = {};
	definition$28.channels.forEach((channel) => {
		if (definition$28.ranges[channel] === void 0) definition$28.ranges[channel] = [0, 1];
		if (!definition$28.interpolate[channel]) throw new Error(`Missing interpolator for: ${channel}`);
		if (typeof definition$28.interpolate[channel] === "function") definition$28.interpolate[channel] = { use: definition$28.interpolate[channel] };
		if (!definition$28.interpolate[channel].fixup) definition$28.interpolate[channel].fixup = identity;
	});
	modes[definition$28.mode] = definition$28;
	(definition$28.parse || []).forEach((parser) => {
		useParser(parser, definition$28.mode);
	});
	return converter_default(definition$28.mode);
};
var getMode = (mode) => modes[mode];
var useParser = (parser, mode) => {
	if (typeof parser === "string") {
		if (!mode) throw new Error(`'mode' required when 'parser' is a string`);
		colorProfiles[parser] = mode;
	} else if (typeof parser === "function") {
		if (parsers.indexOf(parser) < 0) parsers.push(parser);
	}
};
var removeParser = (parser) => {
	if (typeof parser === "string") delete colorProfiles[parser];
	else if (typeof parser === "function") {
		const idx = parsers.indexOf(parser);
		if (idx > 0) parsers.splice(idx, 1);
	}
};

//#endregion
//#region node_modules/culori/src/parse.js
var IdentStartCodePoint = /[^\x00-\x7F]|[a-zA-Z_]/;
var IdentCodePoint = /[^\x00-\x7F]|[-\w]/;
const Tok = {
	Function: "function",
	Ident: "ident",
	Number: "number",
	Percentage: "percentage",
	ParenClose: ")",
	None: "none",
	Hue: "hue",
	Alpha: "alpha"
};
var _i = 0;
function is_num(chars) {
	let ch = chars[_i];
	let ch1 = chars[_i + 1];
	if (ch === "-" || ch === "+") return /\d/.test(ch1) || ch1 === "." && /\d/.test(chars[_i + 2]);
	if (ch === ".") return /\d/.test(ch1);
	return /\d/.test(ch);
}
function is_ident(chars) {
	if (_i >= chars.length) return false;
	let ch = chars[_i];
	if (IdentStartCodePoint.test(ch)) return true;
	if (ch === "-") {
		if (chars.length - _i < 2) return false;
		let ch1 = chars[_i + 1];
		if (ch1 === "-" || IdentStartCodePoint.test(ch1)) return true;
		return false;
	}
	return false;
}
var huenits = {
	deg: 1,
	rad: 180 / Math.PI,
	grad: 9 / 10,
	turn: 360
};
function num(chars) {
	let value = "";
	if (chars[_i] === "-" || chars[_i] === "+") value += chars[_i++];
	value += digits(chars);
	if (chars[_i] === "." && /\d/.test(chars[_i + 1])) value += chars[_i++] + digits(chars);
	if (chars[_i] === "e" || chars[_i] === "E") {
		if ((chars[_i + 1] === "-" || chars[_i + 1] === "+") && /\d/.test(chars[_i + 2])) value += chars[_i++] + chars[_i++] + digits(chars);
		else if (/\d/.test(chars[_i + 1])) value += chars[_i++] + digits(chars);
	}
	if (is_ident(chars)) {
		let id = ident(chars);
		if (id === "deg" || id === "rad" || id === "turn" || id === "grad") return {
			type: Tok.Hue,
			value: value * huenits[id]
		};
		return;
	}
	if (chars[_i] === "%") {
		_i++;
		return {
			type: Tok.Percentage,
			value: +value
		};
	}
	return {
		type: Tok.Number,
		value: +value
	};
}
function digits(chars) {
	let v = "";
	while (/\d/.test(chars[_i])) v += chars[_i++];
	return v;
}
function ident(chars) {
	let v = "";
	while (_i < chars.length && IdentCodePoint.test(chars[_i])) v += chars[_i++];
	return v;
}
function identlike(chars) {
	let v = ident(chars);
	if (chars[_i] === "(") {
		_i++;
		return {
			type: Tok.Function,
			value: v
		};
	}
	if (v === "none") return {
		type: Tok.None,
		value: void 0
	};
	return {
		type: Tok.Ident,
		value: v
	};
}
function tokenize(str = "") {
	let chars = str.trim();
	let tokens = [];
	let ch;
	_i = 0;
	while (_i < chars.length) {
		ch = chars[_i++];
		if (ch === "\n" || ch === "	" || ch === " ") {
			while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) _i++;
			continue;
		}
		if (ch === ",") return;
		if (ch === ")") {
			tokens.push({ type: Tok.ParenClose });
			continue;
		}
		if (ch === "+") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			return;
		}
		if (ch === "-") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			if (is_ident(chars)) {
				tokens.push({
					type: Tok.Ident,
					value: ident(chars)
				});
				continue;
			}
			return;
		}
		if (ch === ".") {
			_i--;
			if (is_num(chars)) {
				tokens.push(num(chars));
				continue;
			}
			return;
		}
		if (ch === "/") {
			while (_i < chars.length && (chars[_i] === "\n" || chars[_i] === "	" || chars[_i] === " ")) _i++;
			let alpha;
			if (is_num(chars)) {
				alpha = num(chars);
				if (alpha.type !== Tok.Hue) {
					tokens.push({
						type: Tok.Alpha,
						value: alpha
					});
					continue;
				}
			}
			if (is_ident(chars)) {
				if (ident(chars) === "none") {
					tokens.push({
						type: Tok.Alpha,
						value: {
							type: Tok.None,
							value: void 0
						}
					});
					continue;
				}
			}
			return;
		}
		if (/\d/.test(ch)) {
			_i--;
			tokens.push(num(chars));
			continue;
		}
		if (IdentStartCodePoint.test(ch)) {
			_i--;
			tokens.push(identlike(chars));
			continue;
		}
		return;
	}
	return tokens;
}
function parseColorSyntax(tokens) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok.Function || token.value !== "color") return;
	token = tokens[tokens._i++];
	if (token.type !== Tok.Ident) return;
	const mode = colorProfiles[token.value];
	if (!mode) return;
	const res = { mode };
	const coords = consumeCoords(tokens, false);
	if (!coords) return;
	const channels = getMode(mode).channels;
	for (let ii = 0, c$1, ch; ii < channels.length; ii++) {
		c$1 = coords[ii];
		ch = channels[ii];
		if (c$1.type !== Tok.None) {
			res[ch] = c$1.type === Tok.Number ? c$1.value : c$1.value / 100;
			if (ch === "alpha") res[ch] = Math.max(0, Math.min(1, res[ch]));
		}
	}
	return res;
}
function consumeCoords(tokens, includeHue) {
	const coords = [];
	let token;
	while (tokens._i < tokens.length) {
		token = tokens[tokens._i++];
		if (token.type === Tok.None || token.type === Tok.Number || token.type === Tok.Alpha || token.type === Tok.Percentage || includeHue && token.type === Tok.Hue) {
			coords.push(token);
			continue;
		}
		if (token.type === Tok.ParenClose) {
			if (tokens._i < tokens.length) return;
			continue;
		}
		return;
	}
	if (coords.length < 3 || coords.length > 4) return;
	if (coords.length === 4) {
		if (coords[3].type !== Tok.Alpha) return;
		coords[3] = coords[3].value;
	}
	if (coords.length === 3) coords.push({
		type: Tok.None,
		value: void 0
	});
	return coords.every((c$1) => c$1.type !== Tok.Alpha) ? coords : void 0;
}
function parseModernSyntax(tokens, includeHue) {
	tokens._i = 0;
	let token = tokens[tokens._i++];
	if (!token || token.type !== Tok.Function) return;
	let coords = consumeCoords(tokens, includeHue);
	if (!coords) return;
	coords.unshift(token.value);
	return coords;
}
var parse = (color) => {
	if (typeof color !== "string") return;
	const tokens = tokenize(color);
	const parsed = tokens ? parseModernSyntax(tokens, true) : void 0;
	let result = void 0;
	let i = 0;
	let len = parsers.length;
	while (i < len) if ((result = parsers[i++](color, parsed)) !== void 0) return result;
	return tokens ? parseColorSyntax(tokens) : void 0;
};
var parse_default = parse;

//#endregion
//#region node_modules/culori/src/rgb/parseRgb.js
function parseRgb(color, parsed) {
	if (!parsed || parsed[0] !== "rgb" && parsed[0] !== "rgba") return;
	const res = { mode: "rgb" };
	const [, r$1, g, b, alpha] = parsed;
	if (r$1.type === Tok.Hue || g.type === Tok.Hue || b.type === Tok.Hue) return;
	if (r$1.type !== Tok.None) res.r = r$1.type === Tok.Number ? r$1.value / 255 : r$1.value / 100;
	if (g.type !== Tok.None) res.g = g.type === Tok.Number ? g.value / 255 : g.value / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value / 255 : b.value / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseRgb_default = parseRgb;

//#endregion
//#region node_modules/culori/src/rgb/parseTransparent.js
var parseTransparent = (c$1) => c$1 === "transparent" ? {
	mode: "rgb",
	r: 0,
	g: 0,
	b: 0,
	alpha: 0
} : void 0;
var parseTransparent_default = parseTransparent;

//#endregion
//#region node_modules/culori/src/interpolate/lerp.js
var lerp = (a, b, t) => a + t * (b - a);
var unlerp = (a, b, v) => (v - a) / (b - a);
var blerp = (a00, a01, a10, a11, tx, ty) => {
	return lerp(lerp(a00, a01, tx), lerp(a10, a11, tx), ty);
};
var trilerp = (a000, a010, a100, a110, a001, a011, a101, a111, tx, ty, tz) => {
	return lerp(blerp(a000, a010, a100, a110, tx, ty), blerp(a001, a011, a101, a111, tx, ty), tz);
};

//#endregion
//#region node_modules/culori/src/interpolate/piecewise.js
var get_classes = (arr) => {
	let classes = [];
	for (let i = 0; i < arr.length - 1; i++) {
		let a = arr[i];
		let b = arr[i + 1];
		if (a === void 0 && b === void 0) classes.push(void 0);
		else if (a !== void 0 && b !== void 0) classes.push([a, b]);
		else classes.push(a !== void 0 ? [a, a] : [b, b]);
	}
	return classes;
};
var interpolatorPiecewise = (interpolator$1) => (arr) => {
	let classes = get_classes(arr);
	return (t) => {
		let cls = t * classes.length;
		let idx = t >= 1 ? classes.length - 1 : Math.max(Math.floor(cls), 0);
		let pair = classes[idx];
		return pair === void 0 ? void 0 : interpolator$1(pair[0], pair[1], cls - idx);
	};
};

//#endregion
//#region node_modules/culori/src/interpolate/linear.js
const interpolatorLinear = interpolatorPiecewise(lerp);

//#endregion
//#region node_modules/culori/src/fixup/alpha.js
var fixupAlpha = (arr) => {
	let some_defined = false;
	let res = arr.map((v) => {
		if (v !== void 0) {
			some_defined = true;
			return v;
		}
		return 1;
	});
	return some_defined ? res : arr;
};

//#endregion
//#region node_modules/culori/src/rgb/definition.js
var definition$27 = {
	mode: "rgb",
	channels: [
		"r",
		"g",
		"b",
		"alpha"
	],
	parse: [
		parseRgb_default,
		parseHex_default,
		parseRgbLegacy_default,
		parseNamed_default,
		parseTransparent_default,
		"srgb"
	],
	serialize: "srgb",
	interpolate: {
		r: interpolatorLinear,
		g: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	gamut: true,
	white: {
		r: 1,
		g: 1,
		b: 1
	},
	black: {
		r: 0,
		g: 0,
		b: 0
	}
};
var definition_default$23 = definition$27;

//#endregion
//#region node_modules/culori/src/a98/convertA98ToXyz65.js
var linearize$2 = (v = 0) => Math.pow(Math.abs(v), 563 / 256) * Math.sign(v);
var convertA98ToXyz65 = (a98$1) => {
	let r$1 = linearize$2(a98$1.r);
	let g = linearize$2(a98$1.g);
	let b = linearize$2(a98$1.b);
	let res = {
		mode: "xyz65",
		x: .5766690429101305 * r$1 + .1855582379065463 * g + .1882286462349947 * b,
		y: .297344975250536 * r$1 + .6273635662554661 * g + .0752914584939979 * b,
		z: .0270313613864123 * r$1 + .0706888525358272 * g + .9913375368376386 * b
	};
	if (a98$1.alpha !== void 0) res.alpha = a98$1.alpha;
	return res;
};
var convertA98ToXyz65_default = convertA98ToXyz65;

//#endregion
//#region node_modules/culori/src/a98/convertXyz65ToA98.js
var gamma$3 = (v) => Math.pow(Math.abs(v), 256 / 563) * Math.sign(v);
var convertXyz65ToA98 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "a98",
		r: gamma$3(x * 2.0415879038107465 - y * .5650069742788597 - .3447313507783297 * z),
		g: gamma$3(x * -.9692436362808798 + y * 1.8759675015077206 + .0415550574071756 * z),
		b: gamma$3(x * .0134442806320312 - y * .1183623922310184 + 1.0151749943912058 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToA98_default = convertXyz65ToA98;

//#endregion
//#region node_modules/culori/src/lrgb/convertRgbToLrgb.js
var fn$3 = (c$1 = 0) => {
	const abs$2 = Math.abs(c$1);
	if (abs$2 <= .04045) return c$1 / 12.92;
	return (Math.sign(c$1) || 1) * Math.pow((abs$2 + .055) / 1.055, 2.4);
};
var convertRgbToLrgb = ({ r: r$1, g, b, alpha }) => {
	let res = {
		mode: "lrgb",
		r: fn$3(r$1),
		g: fn$3(g),
		b: fn$3(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToLrgb_default = convertRgbToLrgb;

//#endregion
//#region node_modules/culori/src/xyz65/convertRgbToXyz65.js
var convertRgbToXyz65 = (rgb$4) => {
	let { r: r$1, g, b, alpha } = convertRgbToLrgb_default(rgb$4);
	let res = {
		mode: "xyz65",
		x: .4123907992659593 * r$1 + .357584339383878 * g + .1804807884018343 * b,
		y: .2126390058715102 * r$1 + .715168678767756 * g + .0721923153607337 * b,
		z: .0193308187155918 * r$1 + .119194779794626 * g + .9505321522496607 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz65_default = convertRgbToXyz65;

//#endregion
//#region node_modules/culori/src/lrgb/convertLrgbToRgb.js
var fn$2 = (c$1 = 0) => {
	const abs$2 = Math.abs(c$1);
	if (abs$2 > .0031308) return (Math.sign(c$1) || 1) * (1.055 * Math.pow(abs$2, 1 / 2.4) - .055);
	return c$1 * 12.92;
};
var convertLrgbToRgb = ({ r: r$1, g, b, alpha }, mode = "rgb") => {
	let res = {
		mode,
		r: fn$2(r$1),
		g: fn$2(g),
		b: fn$2(b)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToRgb_default = convertLrgbToRgb;

//#endregion
//#region node_modules/culori/src/xyz65/convertXyz65ToRgb.js
var convertXyz65ToRgb = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 3.2409699419045226 - y * 1.537383177570094 - .4986107602930034 * z,
		g: x * -.9692436362808796 + y * 1.8759675015077204 + .0415550574071756 * z,
		b: x * .0556300796969936 - y * .2039769588889765 + 1.0569715142428784 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRgb_default = convertXyz65ToRgb;

//#endregion
//#region node_modules/culori/src/a98/definition.js
var definition$26 = {
	...definition_default$23,
	mode: "a98",
	parse: ["a98-rgb"],
	serialize: "a98-rgb",
	fromMode: {
		rgb: (color) => convertXyz65ToA98_default(convertRgbToXyz65_default(color)),
		xyz65: convertXyz65ToA98_default
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default(convertA98ToXyz65_default(color)),
		xyz65: convertA98ToXyz65_default
	}
};
var definition_default = definition$26;

//#endregion
//#region node_modules/culori/src/util/normalizeHue.js
var normalizeHue = (hue$2) => (hue$2 = hue$2 % 360) < 0 ? hue$2 + 360 : hue$2;
var normalizeHue_default = normalizeHue;

//#endregion
//#region node_modules/culori/src/fixup/hue.js
var hue$1 = (hues, fn$4) => {
	return hues.map((hue$2, idx, arr) => {
		if (hue$2 === void 0) return hue$2;
		let normalized = normalizeHue_default(hue$2);
		if (idx === 0 || hues[idx - 1] === void 0) return normalized;
		return fn$4(normalized - normalizeHue_default(arr[idx - 1]));
	}).reduce((acc, curr) => {
		if (!acc.length || curr === void 0 || acc[acc.length - 1] === void 0) {
			acc.push(curr);
			return acc;
		}
		acc.push(curr + acc[acc.length - 1]);
		return acc;
	}, []);
};
var fixupHueShorter = (arr) => hue$1(arr, (d) => Math.abs(d) <= 180 ? d : d - 360 * Math.sign(d));
var fixupHueLonger = (arr) => hue$1(arr, (d) => Math.abs(d) >= 180 || d === 0 ? d : d - 360 * Math.sign(d));
var fixupHueIncreasing = (arr) => hue$1(arr, (d) => d >= 0 ? d : d + 360);
var fixupHueDecreasing = (arr) => hue$1(arr, (d) => d <= 0 ? d : d - 360);

//#endregion
//#region node_modules/culori/src/cubehelix/constants.js
const M = [
	-.14861,
	1.78277,
	-.29227,
	-.90649,
	1.97294,
	0
];
const degToRad = Math.PI / 180;
const radToDeg = 180 / Math.PI;

//#endregion
//#region node_modules/culori/src/cubehelix/convertRgbToCubehelix.js
var DE = M[3] * M[4];
var BE = M[1] * M[4];
var BCAD = M[1] * M[2] - M[0] * M[3];
var convertRgbToCubehelix = ({ r: r$1, g, b, alpha }) => {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let l = (BCAD * b + r$1 * DE - g * BE) / (BCAD + DE - BE);
	let x = b - l;
	let y = (M[4] * (g - l) - M[2] * x) / M[3];
	let res = {
		mode: "cubehelix",
		l,
		s: l === 0 || l === 1 ? void 0 : Math.sqrt(x * x + y * y) / (M[4] * l * (1 - l))
	};
	if (res.s) res.h = Math.atan2(y, x) * radToDeg - 120;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToCubehelix_default = convertRgbToCubehelix;

//#endregion
//#region node_modules/culori/src/cubehelix/convertCubehelixToRgb.js
var convertCubehelixToRgb = ({ h, s, l, alpha }) => {
	let res = { mode: "rgb" };
	h = (h === void 0 ? 0 : h + 120) * degToRad;
	if (l === void 0) l = 0;
	let amp = s === void 0 ? 0 : s * l * (1 - l);
	let cosh = Math.cos(h);
	let sinh = Math.sin(h);
	res.r = l + amp * (M[0] * cosh + M[1] * sinh);
	res.g = l + amp * (M[2] * cosh + M[3] * sinh);
	res.b = l + amp * (M[4] * cosh + M[5] * sinh);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertCubehelixToRgb_default = convertCubehelixToRgb;

//#endregion
//#region node_modules/culori/src/difference.js
var differenceHueSaturation = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.s || !smp.s) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.s * smp.s) * dH;
};
var differenceHueNaive = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	if (Math.abs(smp_h - std_h) > 180) return std_h - (smp_h - 360 * Math.sign(smp_h - std_h));
	return smp_h - std_h;
};
var differenceHueChroma = (std, smp) => {
	if (std.h === void 0 || smp.h === void 0 || !std.c || !smp.c) return 0;
	let std_h = normalizeHue_default(std.h);
	let smp_h = normalizeHue_default(smp.h);
	let dH = Math.sin((smp_h - std_h + 360) / 2 * Math.PI / 180);
	return 2 * Math.sqrt(std.c * smp.c) * dH;
};
var differenceEuclidean = (mode = "rgb", weights = [
	1,
	1,
	1,
	0
]) => {
	let def = getMode(mode);
	let channels = def.channels;
	let diffs = def.difference;
	let conv = converter_default(mode);
	return (std, smp) => {
		let ConvStd = conv(std);
		let ConvSmp = conv(smp);
		return Math.sqrt(channels.reduce((sum, k$3, idx) => {
			let delta = diffs[k$3] ? diffs[k$3](ConvStd, ConvSmp) : ConvStd[k$3] - ConvSmp[k$3];
			return sum + (weights[idx] || 0) * Math.pow(isNaN(delta) ? 0 : delta, 2);
		}, 0));
	};
};
var differenceCie76 = () => differenceEuclidean("lab65");
var differenceCie94 = (kL = 1, K1 = .045, K2 = .015) => {
	let lab$1 = converter_default("lab65");
	return (std, smp) => {
		let LabStd = lab$1(std);
		let LabSmp = lab$1(smp);
		let lStd = LabStd.l;
		let aStd = LabStd.a;
		let bStd = LabStd.b;
		let cStd = Math.sqrt(aStd * aStd + bStd * bStd);
		let lSmp = LabSmp.l;
		let aSmp = LabSmp.a;
		let bSmp = LabSmp.b;
		let cSmp = Math.sqrt(aSmp * aSmp + bSmp * bSmp);
		let dL2 = Math.pow(lStd - lSmp, 2);
		let dC2 = Math.pow(cStd - cSmp, 2);
		let dH2 = Math.pow(aStd - aSmp, 2) + Math.pow(bStd - bSmp, 2) - dC2;
		return Math.sqrt(dL2 / Math.pow(kL, 2) + dC2 / Math.pow(1 + K1 * cStd, 2) + dH2 / Math.pow(1 + K2 * cStd, 2));
	};
};
var differenceCiede2000 = (Kl = 1, Kc = 1, Kh = 1) => {
	let lab$1 = converter_default("lab65");
	return (std, smp) => {
		let LabStd = lab$1(std);
		let LabSmp = lab$1(smp);
		let lStd = LabStd.l;
		let aStd = LabStd.a;
		let bStd = LabStd.b;
		let cStd = Math.sqrt(aStd * aStd + bStd * bStd);
		let lSmp = LabSmp.l;
		let aSmp = LabSmp.a;
		let bSmp = LabSmp.b;
		let cAvg = (cStd + Math.sqrt(aSmp * aSmp + bSmp * bSmp)) / 2;
		let G = .5 * (1 - Math.sqrt(Math.pow(cAvg, 7) / (Math.pow(cAvg, 7) + Math.pow(25, 7))));
		let apStd = aStd * (1 + G);
		let apSmp = aSmp * (1 + G);
		let cpStd = Math.sqrt(apStd * apStd + bStd * bStd);
		let cpSmp = Math.sqrt(apSmp * apSmp + bSmp * bSmp);
		let hpStd = Math.abs(apStd) + Math.abs(bStd) === 0 ? 0 : Math.atan2(bStd, apStd);
		hpStd += (hpStd < 0) * 2 * Math.PI;
		let hpSmp = Math.abs(apSmp) + Math.abs(bSmp) === 0 ? 0 : Math.atan2(bSmp, apSmp);
		hpSmp += (hpSmp < 0) * 2 * Math.PI;
		let dL = lSmp - lStd;
		let dC = cpSmp - cpStd;
		let dhp = cpStd * cpSmp === 0 ? 0 : hpSmp - hpStd;
		dhp -= (dhp > Math.PI) * 2 * Math.PI;
		dhp += (dhp < -Math.PI) * 2 * Math.PI;
		let dH = 2 * Math.sqrt(cpStd * cpSmp) * Math.sin(dhp / 2);
		let Lp = (lStd + lSmp) / 2;
		let Cp = (cpStd + cpSmp) / 2;
		let hp;
		if (cpStd * cpSmp === 0) hp = hpStd + hpSmp;
		else {
			hp = (hpStd + hpSmp) / 2;
			hp -= (Math.abs(hpStd - hpSmp) > Math.PI) * Math.PI;
			hp += (hp < 0) * 2 * Math.PI;
		}
		let Lpm50 = Math.pow(Lp - 50, 2);
		let T = 1 - .17 * Math.cos(hp - Math.PI / 6) + .24 * Math.cos(2 * hp) + .32 * Math.cos(3 * hp + Math.PI / 30) - .2 * Math.cos(4 * hp - 63 * Math.PI / 180);
		let Sl = 1 + .015 * Lpm50 / Math.sqrt(20 + Lpm50);
		let Sc = 1 + .045 * Cp;
		let Sh = 1 + .015 * Cp * T;
		let deltaTheta = 30 * Math.PI / 180 * Math.exp(-1 * Math.pow((180 / Math.PI * hp - 275) / 25, 2));
		let Rc = 2 * Math.sqrt(Math.pow(Cp, 7) / (Math.pow(Cp, 7) + Math.pow(25, 7)));
		let Rt = -1 * Math.sin(2 * deltaTheta) * Rc;
		return Math.sqrt(Math.pow(dL / (Kl * Sl), 2) + Math.pow(dC / (Kc * Sc), 2) + Math.pow(dH / (Kh * Sh), 2) + Rt * dC / (Kc * Sc) * dH / (Kh * Sh));
	};
};
var differenceCmc = (l = 1, c$1 = 1) => {
	let lab$1 = converter_default("lab65");
	return (std, smp) => {
		let LabStd = lab$1(std);
		let lStd = LabStd.l;
		let aStd = LabStd.a;
		let bStd = LabStd.b;
		let cStd = Math.sqrt(aStd * aStd + bStd * bStd);
		let hStd = Math.atan2(bStd, aStd);
		hStd = hStd + 2 * Math.PI * (hStd < 0);
		let LabSmp = lab$1(smp);
		let lSmp = LabSmp.l;
		let aSmp = LabSmp.a;
		let bSmp = LabSmp.b;
		let cSmp = Math.sqrt(aSmp * aSmp + bSmp * bSmp);
		let dL2 = Math.pow(lStd - lSmp, 2);
		let dC2 = Math.pow(cStd - cSmp, 2);
		let dH2 = Math.pow(aStd - aSmp, 2) + Math.pow(bStd - bSmp, 2) - dC2;
		let F = Math.sqrt(Math.pow(cStd, 4) / (Math.pow(cStd, 4) + 1900));
		let T = hStd >= 164 / 180 * Math.PI && hStd <= 345 / 180 * Math.PI ? .56 + Math.abs(.2 * Math.cos(hStd + 168 / 180 * Math.PI)) : .36 + Math.abs(.4 * Math.cos(hStd + 35 / 180 * Math.PI));
		let Sl = lStd < 16 ? .511 : .040975 * lStd / (1 + .01765 * lStd);
		let Sc = .0638 * cStd / (1 + .0131 * cStd) + .638;
		let Sh = Sc * (F * T + 1 - F);
		return Math.sqrt(dL2 / Math.pow(l * Sl, 2) + dC2 / Math.pow(c$1 * Sc, 2) + dH2 / Math.pow(Sh, 2));
	};
};
var differenceHyab = () => {
	let lab$1 = converter_default("lab65");
	return (std, smp) => {
		let LabStd = lab$1(std);
		let LabSmp = lab$1(smp);
		let dL = LabStd.l - LabSmp.l;
		let dA = LabStd.a - LabSmp.a;
		let dB = LabStd.b - LabSmp.b;
		return Math.abs(dL) + Math.sqrt(dA * dA + dB * dB);
	};
};
var differenceKotsarenkoRamos = () => differenceEuclidean("yiq", [
	.5053,
	.299,
	.1957
]);
var differenceItp = () => differenceEuclidean("itp", [
	518400,
	129600,
	518400
]);

//#endregion
//#region node_modules/culori/src/average.js
var averageAngle = (val) => {
	let sum = val.reduce((sum$1, val$1) => {
		if (val$1 !== void 0) {
			let rad = val$1 * Math.PI / 180;
			sum$1.sin += Math.sin(rad);
			sum$1.cos += Math.cos(rad);
		}
		return sum$1;
	}, {
		sin: 0,
		cos: 0
	});
	let angle = Math.atan2(sum.sin, sum.cos) * 180 / Math.PI;
	return angle < 0 ? 360 + angle : angle;
};
var averageNumber = (val) => {
	let a = val.filter((v) => v !== void 0);
	return a.length ? a.reduce((sum, v) => sum + v, 0) / a.length : void 0;
};
var isfn$1 = (o) => typeof o === "function";
function average(colors, mode = "rgb", overrides) {
	let def = getMode(mode);
	let cc = colors.map(converter_default(mode));
	return def.channels.reduce((res, ch) => {
		let arr = cc.map((c$1) => c$1[ch]).filter((val) => val !== void 0);
		if (arr.length) {
			let fn$4;
			if (isfn$1(overrides)) fn$4 = overrides;
			else if (overrides && isfn$1(overrides[ch])) fn$4 = overrides[ch];
			else if (def.average && isfn$1(def.average[ch])) fn$4 = def.average[ch];
			else fn$4 = averageNumber;
			res[ch] = fn$4(arr, ch);
		}
		return res;
	}, { mode });
}

//#endregion
//#region node_modules/culori/src/cubehelix/definition.js
var definition$25 = {
	mode: "cubehelix",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--cubehelix"],
	serialize: "--cubehelix",
	ranges: {
		h: [0, 360],
		s: [0, 4.614],
		l: [0, 1]
	},
	fromMode: { rgb: convertRgbToCubehelix_default },
	toMode: { rgb: convertCubehelixToRgb_default },
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$1 = definition$25;

//#endregion
//#region node_modules/culori/src/lch/convertLabToLch.js
var convertLabToLch = ({ l, a, b, alpha }, mode = "lch") => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$1 = Math.sqrt(a * a + b * b);
	let res = {
		mode,
		l,
		c: c$1
	};
	if (c$1) res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToLch_default = convertLabToLch;

//#endregion
//#region node_modules/culori/src/lch/convertLchToLab.js
var convertLchToLab = ({ l, c: c$1, h, alpha }, mode = "lab") => {
	if (h === void 0) h = 0;
	let res = {
		mode,
		l,
		a: c$1 ? c$1 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$1 ? c$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchToLab_default = convertLchToLab;

//#endregion
//#region node_modules/culori/src/xyz65/constants.js
const k$1 = Math.pow(29, 3) / Math.pow(3, 3);
const e$1 = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region node_modules/culori/src/constants.js
const D50 = {
	X: .3457 / .3585,
	Y: 1,
	Z: .2958 / .3585
};
const D65 = {
	X: .3127 / .329,
	Y: 1,
	Z: .3583 / .329
};
const k$2 = Math.pow(29, 3) / Math.pow(3, 3);
const e$2 = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region node_modules/culori/src/lab65/convertLab65ToXyz65.js
var fn$1 = (v) => Math.pow(v, 3) > e$1 ? Math.pow(v, 3) : (116 * v - 16) / k$1;
var convertLab65ToXyz65 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz65",
		x: fn$1(fx) * D65.X,
		y: fn$1(fy) * D65.Y,
		z: fn$1(fz) * D65.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToXyz65_default = convertLab65ToXyz65;

//#endregion
//#region node_modules/culori/src/lab65/convertLab65ToRgb.js
var convertLab65ToRgb = (lab$1) => convertXyz65ToRgb_default(convertLab65ToXyz65_default(lab$1));
var convertLab65ToRgb_default = convertLab65ToRgb;

//#endregion
//#region node_modules/culori/src/lab65/convertXyz65ToLab65.js
var f$1 = (value) => value > e$1 ? Math.cbrt(value) : (k$1 * value + 16) / 116;
var convertXyz65ToLab65 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f$1(x / D65.X);
	let f1 = f$1(y / D65.Y);
	let f2 = f$1(z / D65.Z);
	let res = {
		mode: "lab65",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToLab65_default = convertXyz65ToLab65;

//#endregion
//#region node_modules/culori/src/lab65/convertRgbToLab65.js
var convertRgbToLab65 = (rgb$4) => {
	let res = convertXyz65ToLab65_default(convertRgbToXyz65_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab65_default = convertRgbToLab65;

//#endregion
//#region node_modules/culori/src/dlch/constants.js
const kE = 1;
const kCH = 1;
const θ = 26 / 180 * Math.PI;
const cosθ = Math.cos(θ);
const sinθ = Math.sin(θ);
const factor = 100 / Math.log(139 / 100);

//#endregion
//#region node_modules/culori/src/dlch/convertDlchToLab65.js
var convertDlchToLab65 = ({ l, c: c$1, h, alpha }) => {
	if (l === void 0) l = 0;
	if (c$1 === void 0) c$1 = 0;
	if (h === void 0) h = 0;
	let res = {
		mode: "lab65",
		l: (Math.exp(l * kE / factor) - 1) / .0039
	};
	let G = (Math.exp(.0435 * c$1 * kCH * kE) - 1) / .075;
	let e$3 = G * Math.cos(h / 180 * Math.PI - θ);
	let f$2 = G * Math.sin(h / 180 * Math.PI - θ);
	res.a = e$3 * cosθ - f$2 / .83 * sinθ;
	res.b = e$3 * sinθ + f$2 / .83 * cosθ;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertDlchToLab65_default = convertDlchToLab65;

//#endregion
//#region node_modules/culori/src/dlch/convertLab65ToDlch.js
var convertLab65ToDlch = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let e$3 = a * cosθ + b * sinθ;
	let f$2 = .83 * (b * cosθ - a * sinθ);
	let G = Math.sqrt(e$3 * e$3 + f$2 * f$2);
	let res = {
		mode: "dlch",
		l: factor / kE * Math.log(1 + .0039 * l),
		c: Math.log(1 + .075 * G) / (.0435 * kCH * kE)
	};
	if (res.c) res.h = normalizeHue_default((Math.atan2(f$2, e$3) + θ) / Math.PI * 180);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLab65ToDlch_default = convertLab65ToDlch;

//#endregion
//#region node_modules/culori/src/dlab/definition.js
var convertDlabToLab65 = (c$1) => convertDlchToLab65_default(convertLabToLch_default(c$1, "dlch"));
var convertLab65ToDlab = (c$1) => convertLchToLab_default(convertLab65ToDlch_default(c$1), "dlab");
var definition$24 = {
	mode: "dlab",
	parse: ["--din99o-lab"],
	serialize: "--din99o-lab",
	toMode: {
		lab65: convertDlabToLab65,
		rgb: (c$1) => convertLab65ToRgb_default(convertDlabToLab65(c$1))
	},
	fromMode: {
		lab65: convertLab65ToDlab,
		rgb: (c$1) => convertLab65ToDlab(convertRgbToLab65_default(c$1))
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-40.09, 45.501],
		b: [-40.469, 44.344]
	},
	interpolate: {
		l: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$2 = definition$24;

//#endregion
//#region node_modules/culori/src/dlch/definition.js
var definition$23 = {
	mode: "dlch",
	parse: ["--din99o-lch"],
	serialize: "--din99o-lch",
	toMode: {
		lab65: convertDlchToLab65_default,
		dlab: (c$1) => convertLchToLab_default(c$1, "dlab"),
		rgb: (c$1) => convertLab65ToRgb_default(convertDlchToLab65_default(c$1))
	},
	fromMode: {
		lab65: convertLab65ToDlch_default,
		dlab: (c$1) => convertLabToLch_default(c$1, "dlch"),
		rgb: (c$1) => convertLab65ToDlch_default(convertRgbToLab65_default(c$1))
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 51.484],
		h: [0, 360]
	},
	interpolate: {
		l: interpolatorLinear,
		c: interpolatorLinear,
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$3 = definition$23;

//#endregion
//#region node_modules/culori/src/hsi/convertHsiToRgb.js
function convertHsiToRgb({ h, s, i, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (i === void 0) i = 0;
	let f$2 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: i * (1 + s * (3 / (2 - f$2) - 1)),
				g: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				b: i * (1 - s)
			};
			break;
		case 1:
			res = {
				r: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				g: i * (1 + s * (3 / (2 - f$2) - 1)),
				b: i * (1 - s)
			};
			break;
		case 2:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 / (2 - f$2) - 1)),
				b: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1))
			};
			break;
		case 3:
			res = {
				r: i * (1 - s),
				g: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				b: i * (1 + s * (3 / (2 - f$2) - 1))
			};
			break;
		case 4:
			res = {
				r: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 / (2 - f$2) - 1))
			};
			break;
		case 5:
			res = {
				r: i * (1 + s * (3 / (2 - f$2) - 1)),
				g: i * (1 - s),
				b: i * (1 + s * (3 * (1 - f$2) / (2 - f$2) - 1))
			};
			break;
		default: res = {
			r: i * (1 - s),
			g: i * (1 - s),
			b: i * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/hsi/convertRgbToHsi.js
function convertRgbToHsi({ r: r$1, g, b, alpha }) {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1 = Math.max(r$1, g, b), m = Math.min(r$1, g, b);
	let res = {
		mode: "hsi",
		s: r$1 + g + b === 0 ? 0 : 1 - 3 * m / (r$1 + g + b),
		i: (r$1 + g + b) / 3
	};
	if (M$1 - m !== 0) res.h = (M$1 === r$1 ? (g - b) / (M$1 - m) + (g < b) * 6 : M$1 === g ? (b - r$1) / (M$1 - m) + 2 : (r$1 - g) / (M$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/hsi/definition.js
var definition$22 = {
	mode: "hsi",
	toMode: { rgb: convertHsiToRgb },
	parse: ["--hsi"],
	serialize: "--hsi",
	fromMode: { rgb: convertRgbToHsi },
	channels: [
		"h",
		"s",
		"i",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		i: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$4 = definition$22;

//#endregion
//#region node_modules/culori/src/hsl/convertHslToRgb.js
function convertHslToRgb({ h, s, l, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (l === void 0) l = 0;
	let m1 = l + s * (l < .5 ? l : 1 - l);
	let m2 = m1 - (m1 - l) * 2 * Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: m1,
				g: m2,
				b: 2 * l - m1
			};
			break;
		case 1:
			res = {
				r: m2,
				g: m1,
				b: 2 * l - m1
			};
			break;
		case 2:
			res = {
				r: 2 * l - m1,
				g: m1,
				b: m2
			};
			break;
		case 3:
			res = {
				r: 2 * l - m1,
				g: m2,
				b: m1
			};
			break;
		case 4:
			res = {
				r: m2,
				g: 2 * l - m1,
				b: m1
			};
			break;
		case 5:
			res = {
				r: m1,
				g: 2 * l - m1,
				b: m2
			};
			break;
		default: res = {
			r: 2 * l - m1,
			g: 2 * l - m1,
			b: 2 * l - m1
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/hsl/convertRgbToHsl.js
function convertRgbToHsl({ r: r$1, g, b, alpha }) {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1 = Math.max(r$1, g, b), m = Math.min(r$1, g, b);
	let res = {
		mode: "hsl",
		s: M$1 === m ? 0 : (M$1 - m) / (1 - Math.abs(M$1 + m - 1)),
		l: .5 * (M$1 + m)
	};
	if (M$1 - m !== 0) res.h = (M$1 === r$1 ? (g - b) / (M$1 - m) + (g < b) * 6 : M$1 === g ? (b - r$1) / (M$1 - m) + 2 : (r$1 - g) / (M$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/util/hue.js
var hueToDeg = (val, unit) => {
	switch (unit) {
		case "deg": return +val;
		case "rad": return val / Math.PI * 180;
		case "grad": return val / 10 * 9;
		case "turn": return val * 360;
	}
};
var hue_default = hueToDeg;

//#endregion
//#region node_modules/culori/src/hsl/parseHslLegacy.js
var hsl_old = /* @__PURE__ */ new RegExp(`^hsla?\\(\\s*${hue}${c}${per}${c}${per}\\s*(?:,\\s*${num_per}\\s*)?\\)$`);
var parseHslLegacy = (color) => {
	let match = color.match(hsl_old);
	if (!match) return;
	let res = { mode: "hsl" };
	if (match[3] !== void 0) res.h = +match[3];
	else if (match[1] !== void 0 && match[2] !== void 0) res.h = hue_default(match[1], match[2]);
	if (match[4] !== void 0) res.s = Math.min(Math.max(0, match[4] / 100), 1);
	if (match[5] !== void 0) res.l = Math.min(Math.max(0, match[5] / 100), 1);
	if (match[6] !== void 0) res.alpha = Math.max(0, Math.min(1, match[6] / 100));
	else if (match[7] !== void 0) res.alpha = Math.max(0, Math.min(1, +match[7]));
	return res;
};
var parseHslLegacy_default = parseHslLegacy;

//#endregion
//#region node_modules/culori/src/hsl/parseHsl.js
function parseHsl(color, parsed) {
	if (!parsed || parsed[0] !== "hsl" && parsed[0] !== "hsla") return;
	const res = { mode: "hsl" };
	const [, h, s, l, alpha] = parsed;
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (s.type !== Tok.None) {
		if (s.type === Tok.Hue) return;
		res.s = s.value / 100;
	}
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = l.value / 100;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHsl_default = parseHsl;

//#endregion
//#region node_modules/culori/src/hsl/definition.js
var definition$21 = {
	mode: "hsl",
	toMode: { rgb: convertHslToRgb },
	fromMode: { rgb: convertRgbToHsl },
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHsl_default, parseHslLegacy_default],
	serialize: (c$1) => `hsl(${c$1.h !== void 0 ? c$1.h : "none"} ${c$1.s !== void 0 ? c$1.s * 100 + "%" : "none"} ${c$1.l !== void 0 ? c$1.l * 100 + "%" : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$5 = definition$21;

//#endregion
//#region node_modules/culori/src/hsv/convertHsvToRgb.js
function convertHsvToRgb({ h, s, v, alpha }) {
	h = normalizeHue_default(h !== void 0 ? h : 0);
	if (s === void 0) s = 0;
	if (v === void 0) v = 0;
	let f$2 = Math.abs(h / 60 % 2 - 1);
	let res;
	switch (Math.floor(h / 60)) {
		case 0:
			res = {
				r: v,
				g: v * (1 - s * f$2),
				b: v * (1 - s)
			};
			break;
		case 1:
			res = {
				r: v * (1 - s * f$2),
				g: v,
				b: v * (1 - s)
			};
			break;
		case 2:
			res = {
				r: v * (1 - s),
				g: v,
				b: v * (1 - s * f$2)
			};
			break;
		case 3:
			res = {
				r: v * (1 - s),
				g: v * (1 - s * f$2),
				b: v
			};
			break;
		case 4:
			res = {
				r: v * (1 - s * f$2),
				g: v * (1 - s),
				b: v
			};
			break;
		case 5:
			res = {
				r: v,
				g: v * (1 - s),
				b: v * (1 - s * f$2)
			};
			break;
		default: res = {
			r: v * (1 - s),
			g: v * (1 - s),
			b: v * (1 - s)
		};
	}
	res.mode = "rgb";
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/hsv/convertRgbToHsv.js
function convertRgbToHsv({ r: r$1, g, b, alpha }) {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let M$1 = Math.max(r$1, g, b), m = Math.min(r$1, g, b);
	let res = {
		mode: "hsv",
		s: M$1 === 0 ? 0 : 1 - m / M$1,
		v: M$1
	};
	if (M$1 - m !== 0) res.h = (M$1 === r$1 ? (g - b) / (M$1 - m) + (g < b) * 6 : M$1 === g ? (b - r$1) / (M$1 - m) + 2 : (r$1 - g) / (M$1 - m) + 4) * 60;
	if (alpha !== void 0) res.alpha = alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/hsv/definition.js
var definition$20 = {
	mode: "hsv",
	toMode: { rgb: convertHsvToRgb },
	parse: ["--hsv"],
	serialize: "--hsv",
	fromMode: { rgb: convertRgbToHsv },
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		s: interpolatorLinear,
		v: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueSaturation },
	average: { h: averageAngle }
};
var definition_default$6 = definition$20;

//#endregion
//#region node_modules/culori/src/hwb/convertHwbToRgb.js
function convertHwbToRgb({ h, w, b, alpha }) {
	if (w === void 0) w = 0;
	if (b === void 0) b = 0;
	if (w + b > 1) {
		let s = w + b;
		w /= s;
		b /= s;
	}
	return convertHsvToRgb({
		h,
		s: b === 1 ? 1 : 1 - w / (1 - b),
		v: 1 - b,
		alpha
	});
}

//#endregion
//#region node_modules/culori/src/hwb/convertRgbToHwb.js
function convertRgbToHwb(rgba) {
	let hsv$1 = convertRgbToHsv(rgba);
	if (hsv$1 === void 0) return void 0;
	let s = hsv$1.s !== void 0 ? hsv$1.s : 0;
	let v = hsv$1.v !== void 0 ? hsv$1.v : 0;
	let res = {
		mode: "hwb",
		w: (1 - s) * v,
		b: 1 - v
	};
	if (hsv$1.h !== void 0) res.h = hsv$1.h;
	if (hsv$1.alpha !== void 0) res.alpha = hsv$1.alpha;
	return res;
}

//#endregion
//#region node_modules/culori/src/hwb/parseHwb.js
function ParseHwb(color, parsed) {
	if (!parsed || parsed[0] !== "hwb") return;
	const res = { mode: "hwb" };
	const [, h, w, b, alpha] = parsed;
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (w.type !== Tok.None) {
		if (w.type === Tok.Hue) return;
		res.w = w.value / 100;
	}
	if (b.type !== Tok.None) {
		if (b.type === Tok.Hue) return;
		res.b = b.value / 100;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseHwb_default = ParseHwb;

//#endregion
//#region node_modules/culori/src/hwb/definition.js
var definition$19 = {
	mode: "hwb",
	toMode: { rgb: convertHwbToRgb },
	fromMode: { rgb: convertRgbToHwb },
	channels: [
		"h",
		"w",
		"b",
		"alpha"
	],
	ranges: { h: [0, 360] },
	gamut: "rgb",
	parse: [parseHwb_default],
	serialize: (c$1) => `hwb(${c$1.h !== void 0 ? c$1.h : "none"} ${c$1.w !== void 0 ? c$1.w * 100 + "%" : "none"} ${c$1.b !== void 0 ? c$1.b * 100 + "%" : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		w: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueNaive },
	average: { h: averageAngle }
};
var definition_default$7 = definition$19;

//#endregion
//#region node_modules/culori/src/hdr/constants.js
const YW = 203;

//#endregion
//#region node_modules/culori/src/hdr/transfer.js
const M1 = .1593017578125;
const M2 = 78.84375;
const C1 = .8359375;
const C2 = 18.8515625;
const C3 = 18.6875;
function transferPqDecode(v) {
	if (v < 0) return 0;
	const c$1 = Math.pow(v, 1 / M2);
	return 1e4 * Math.pow(Math.max(0, c$1 - C1) / (C2 - C3 * c$1), 1 / M1);
}
function transferPqEncode(v) {
	if (v < 0) return 0;
	const c$1 = Math.pow(v / 1e4, M1);
	return Math.pow((C1 + C2 * c$1) / (1 + C3 * c$1), M2);
}

//#endregion
//#region node_modules/culori/src/itp/convertItpToXyz65.js
var toRel = (c$1) => Math.max(c$1 / YW, 0);
var convertItpToXyz65 = ({ i, t, p: p$2, alpha }) => {
	if (i === void 0) i = 0;
	if (t === void 0) t = 0;
	if (p$2 === void 0) p$2 = 0;
	const l = transferPqDecode(i + .008609037037932761 * t + .11102962500302593 * p$2);
	const m = transferPqDecode(i - .00860903703793275 * t - .11102962500302599 * p$2);
	const s = transferPqDecode(i + .5600313357106791 * t - .32062717498731885 * p$2);
	const res = {
		mode: "xyz65",
		x: toRel(2.070152218389422 * l - 1.3263473389671556 * m + .2066510476294051 * s),
		y: toRel(.3647385209748074 * l + .680566024947227 * m - .0453045459220346 * s),
		z: toRel(-.049747207535812 * l - .0492609666966138 * m + 1.1880659249923042 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertItpToXyz65_default = convertItpToXyz65;

//#endregion
//#region node_modules/culori/src/itp/convertXyz65ToItp.js
var toAbs = (c$1 = 0) => Math.max(c$1 * YW, 0);
var convertXyz65ToItp = ({ x, y, z, alpha }) => {
	const absX = toAbs(x);
	const absY = toAbs(y);
	const absZ = toAbs(z);
	const l = transferPqEncode(.3592832590121217 * absX + .6976051147779502 * absY - .0358915932320289 * absZ);
	const m = transferPqEncode(-.1920808463704995 * absX + 1.1004767970374323 * absY + .0753748658519118 * absZ);
	const s = transferPqEncode(.0070797844607477 * absX + .0748396662186366 * absY + .8433265453898765 * absZ);
	const res = {
		mode: "itp",
		i: .5 * l + .5 * m,
		t: 1.61376953125 * l - 3.323486328125 * m + 1.709716796875 * s,
		p: 4.378173828125 * l - 4.24560546875 * m - .132568359375 * s
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToItp_default = convertXyz65ToItp;

//#endregion
//#region node_modules/culori/src/itp/definition.js
var definition$18 = {
	mode: "itp",
	channels: [
		"i",
		"t",
		"p",
		"alpha"
	],
	parse: ["--ictcp"],
	serialize: "--ictcp",
	toMode: {
		xyz65: convertItpToXyz65_default,
		rgb: (color) => convertXyz65ToRgb_default(convertItpToXyz65_default(color))
	},
	fromMode: {
		xyz65: convertXyz65ToItp_default,
		rgb: (color) => convertXyz65ToItp_default(convertRgbToXyz65_default(color))
	},
	ranges: {
		i: [0, .581],
		t: [-.369, .272],
		p: [-.164, .331]
	},
	interpolate: {
		i: interpolatorLinear,
		t: interpolatorLinear,
		p: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$8 = definition$18;

//#endregion
//#region node_modules/culori/src/jab/convertXyz65ToJab.js
var p$1 = 134.03437499999998;
var d0$1 = 16295499532821565e-27;
var jabPqEncode = (v) => {
	if (v < 0) return 0;
	let vn$2 = Math.pow(v / 1e4, M1);
	return Math.pow((C1 + C2 * vn$2) / (1 + C3 * vn$2), p$1);
};
var abs$1 = (v = 0) => Math.max(v * 203, 0);
var convertXyz65ToJab = ({ x, y, z, alpha }) => {
	x = abs$1(x);
	y = abs$1(y);
	z = abs$1(z);
	let xp = 1.15 * x - .15 * z;
	let yp = .66 * y + .34 * x;
	let l = jabPqEncode(.41478972 * xp + .579999 * yp + .014648 * z);
	let m = jabPqEncode(-.20151 * xp + 1.120649 * yp + .0531008 * z);
	let s = jabPqEncode(-.0166008 * xp + .2648 * yp + .6684799 * z);
	let i = (l + m) / 2;
	let res = {
		mode: "jab",
		j: .44 * i / (1 - .56 * i) - d0$1,
		a: 3.524 * l - 4.066708 * m + .542708 * s,
		b: .199076 * l + 1.096799 * m - 1.295875 * s
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToJab_default = convertXyz65ToJab;

//#endregion
//#region node_modules/culori/src/jab/convertJabToXyz65.js
var p = 134.03437499999998;
var d0 = 16295499532821565e-27;
var jabPqDecode = (v) => {
	if (v < 0) return 0;
	let vp = Math.pow(v, 1 / p);
	return 1e4 * Math.pow((C1 - vp) / (C3 * vp - C2), 1 / M1);
};
var rel = (v) => v / 203;
var convertJabToXyz65 = ({ j, a, b, alpha }) => {
	if (j === void 0) j = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let i = (j + d0) / (.44 + .56 * (j + d0));
	let l = jabPqDecode(i + .13860504 * a + .058047316 * b);
	let m = jabPqDecode(i - .13860504 * a - .058047316 * b);
	let s = jabPqDecode(i - .096019242 * a - .8118919 * b);
	let res = {
		mode: "xyz65",
		x: rel(1.661373024652174 * l - .914523081304348 * m + .23136208173913045 * s),
		y: rel(-.3250758611844533 * l + 1.571847026732543 * m - .21825383453227928 * s),
		z: rel(-.090982811 * l - .31272829 * m + 1.5227666 * s)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToXyz65_default = convertJabToXyz65;

//#endregion
//#region node_modules/culori/src/jab/convertRgbToJab.js
var convertRgbToJab = (rgb$4) => {
	let res = convertXyz65ToJab_default(convertRgbToXyz65_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToJab_default = convertRgbToJab;

//#endregion
//#region node_modules/culori/src/jab/convertJabToRgb.js
var convertJabToRgb = (color) => convertXyz65ToRgb_default(convertJabToXyz65_default(color));
var convertJabToRgb_default = convertJabToRgb;

//#endregion
//#region node_modules/culori/src/jab/definition.js
var definition$17 = {
	mode: "jab",
	channels: [
		"j",
		"a",
		"b",
		"alpha"
	],
	parse: ["--jzazbz"],
	serialize: "--jzazbz",
	fromMode: {
		rgb: convertRgbToJab_default,
		xyz65: convertXyz65ToJab_default
	},
	toMode: {
		rgb: convertJabToRgb_default,
		xyz65: convertJabToXyz65_default
	},
	ranges: {
		j: [0, .222],
		a: [-.109, .129],
		b: [-.185, .134]
	},
	interpolate: {
		j: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$9 = definition$17;

//#endregion
//#region node_modules/culori/src/jch/convertJabToJch.js
var convertJabToJch = ({ j, a, b, alpha }) => {
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let c$1 = Math.sqrt(a * a + b * b);
	let res = {
		mode: "jch",
		j,
		c: c$1
	};
	if (c$1) res.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJabToJch_default = convertJabToJch;

//#endregion
//#region node_modules/culori/src/jch/convertJchToJab.js
var convertJchToJab = ({ j, c: c$1, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "jab",
		j,
		a: c$1 ? c$1 * Math.cos(h / 180 * Math.PI) : 0,
		b: c$1 ? c$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertJchToJab_default = convertJchToJab;

//#endregion
//#region node_modules/culori/src/jch/definition.js
var definition$16 = {
	mode: "jch",
	parse: ["--jzczhz"],
	serialize: "--jzczhz",
	toMode: {
		jab: convertJchToJab_default,
		rgb: (c$1) => convertJabToRgb_default(convertJchToJab_default(c$1))
	},
	fromMode: {
		rgb: (c$1) => convertJabToJch_default(convertRgbToJab_default(c$1)),
		jab: convertJabToJch_default
	},
	channels: [
		"j",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		j: [0, .221],
		c: [0, .19],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		j: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$10 = definition$16;

//#endregion
//#region node_modules/culori/src/xyz50/constants.js
const k = Math.pow(29, 3) / Math.pow(3, 3);
const e = Math.pow(6, 3) / Math.pow(29, 3);

//#endregion
//#region node_modules/culori/src/lab/convertLabToXyz50.js
var fn = (v) => Math.pow(v, 3) > e ? Math.pow(v, 3) : (116 * v - 16) / k;
var convertLabToXyz50 = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let fy = (l + 16) / 116;
	let fx = a / 500 + fy;
	let fz = fy - b / 200;
	let res = {
		mode: "xyz50",
		x: fn(fx) * D50.X,
		y: fn(fy) * D50.Y,
		z: fn(fz) * D50.Z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLabToXyz50_default = convertLabToXyz50;

//#endregion
//#region node_modules/culori/src/xyz50/convertXyz50ToRgb.js
var convertXyz50ToRgb = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 3.1341359569958707 - y * 1.6173863321612538 - .4906619460083532 * z,
		g: x * -.978795502912089 + y * 1.916254567259524 + .03344273116131949 * z,
		b: x * .07195537988411677 - y * .2289768264158322 + 1.405386058324125 * z
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToRgb_default = convertXyz50ToRgb;

//#endregion
//#region node_modules/culori/src/lab/convertLabToRgb.js
var convertLabToRgb = (lab$1) => convertXyz50ToRgb_default(convertLabToXyz50_default(lab$1));
var convertLabToRgb_default = convertLabToRgb;

//#endregion
//#region node_modules/culori/src/xyz50/convertRgbToXyz50.js
var convertRgbToXyz50 = (rgb$4) => {
	let { r: r$1, g, b, alpha } = convertRgbToLrgb_default(rgb$4);
	let res = {
		mode: "xyz50",
		x: .436065742824811 * r$1 + .3851514688337912 * g + .14307845442264197 * b,
		y: .22249319175623702 * r$1 + .7168870538238823 * g + .06061979053616537 * b,
		z: .013923904500943465 * r$1 + .09708128566574634 * g + .7140993584005155 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyz50_default = convertRgbToXyz50;

//#endregion
//#region node_modules/culori/src/lab/convertXyz50ToLab.js
var f = (value) => value > e ? Math.cbrt(value) : (k * value + 16) / 116;
var convertXyz50ToLab = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let f0 = f(x / D50.X);
	let f1 = f(y / D50.Y);
	let f2 = f(z / D50.Z);
	let res = {
		mode: "lab",
		l: 116 * f1 - 16,
		a: 500 * (f0 - f1),
		b: 200 * (f1 - f2)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLab_default = convertXyz50ToLab;

//#endregion
//#region node_modules/culori/src/lab/convertRgbToLab.js
var convertRgbToLab = (rgb$4) => {
	let res = convertXyz50ToLab_default(convertRgbToXyz50_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToLab_default = convertRgbToLab;

//#endregion
//#region node_modules/culori/src/lab/parseLab.js
function parseLab(color, parsed) {
	if (!parsed || parsed[0] !== "lab") return;
	const res = { mode: "lab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) return;
	if (l.type !== Tok.None) res.l = Math.min(Math.max(0, l.value), 100);
	if (a.type !== Tok.None) res.a = a.type === Tok.Number ? a.value : a.value * 125 / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value : b.value * 125 / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseLab_default = parseLab;

//#endregion
//#region node_modules/culori/src/lab/definition.js
var definition$15 = {
	mode: "lab",
	toMode: {
		xyz50: convertLabToXyz50_default,
		rgb: convertLabToRgb_default
	},
	fromMode: {
		xyz50: convertXyz50ToLab_default,
		rgb: convertRgbToLab_default
	},
	channels: [
		"l",
		"a",
		"b",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	},
	parse: [parseLab_default],
	serialize: (c$1) => `lab(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.a !== void 0 ? c$1.a : "none"} ${c$1.b !== void 0 ? c$1.b : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		l: interpolatorLinear,
		a: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$11 = definition$15;

//#endregion
//#region node_modules/culori/src/lab65/definition.js
var definition$14 = {
	...definition_default$11,
	mode: "lab65",
	parse: ["--lab-d65"],
	serialize: "--lab-d65",
	toMode: {
		xyz65: convertLab65ToXyz65_default,
		rgb: convertLab65ToRgb_default
	},
	fromMode: {
		xyz65: convertXyz65ToLab65_default,
		rgb: convertRgbToLab65_default
	},
	ranges: {
		l: [0, 100],
		a: [-125, 125],
		b: [-125, 125]
	}
};
var definition_default$12 = definition$14;

//#endregion
//#region node_modules/culori/src/lch/parseLch.js
function parseLch(color, parsed) {
	if (!parsed || parsed[0] !== "lch") return;
	const res = { mode: "lch" };
	const [, l, c$1, h, alpha] = parsed;
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = Math.min(Math.max(0, l.value), 100);
	}
	if (c$1.type !== Tok.None) res.c = Math.max(0, c$1.type === Tok.Number ? c$1.value : c$1.value * 150 / 100);
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseLch_default = parseLch;

//#endregion
//#region node_modules/culori/src/lch/definition.js
var definition$13 = {
	mode: "lch",
	toMode: {
		lab: convertLchToLab_default,
		rgb: (c$1) => convertLabToRgb_default(convertLchToLab_default(c$1))
	},
	fromMode: {
		rgb: (c$1) => convertLabToLch_default(convertRgbToLab_default(c$1)),
		lab: convertLabToLch_default
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	},
	parse: [parseLch_default],
	serialize: (c$1) => `lch(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.c !== void 0 ? c$1.c : "none"} ${c$1.h !== void 0 ? c$1.h : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$13 = definition$13;

//#endregion
//#region node_modules/culori/src/lch65/definition.js
var definition$12 = {
	...definition_default$13,
	mode: "lch65",
	parse: ["--lch-d65"],
	serialize: "--lch-d65",
	toMode: {
		lab65: (c$1) => convertLchToLab_default(c$1, "lab65"),
		rgb: (c$1) => convertLab65ToRgb_default(convertLchToLab_default(c$1, "lab65"))
	},
	fromMode: {
		rgb: (c$1) => convertLabToLch_default(convertRgbToLab65_default(c$1), "lch65"),
		lab65: (c$1) => convertLabToLch_default(c$1, "lch65")
	},
	ranges: {
		l: [0, 100],
		c: [0, 150],
		h: [0, 360]
	}
};
var definition_default$14 = definition$12;

//#endregion
//#region node_modules/culori/src/lchuv/convertLuvToLchuv.js
var convertLuvToLchuv = ({ l, u, v, alpha }) => {
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let c$1 = Math.sqrt(u * u + v * v);
	let res = {
		mode: "lchuv",
		l,
		c: c$1
	};
	if (c$1) res.h = normalizeHue_default(Math.atan2(v, u) * 180 / Math.PI);
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToLchuv_default = convertLuvToLchuv;

//#endregion
//#region node_modules/culori/src/lchuv/convertLchuvToLuv.js
var convertLchuvToLuv = ({ l, c: c$1, h, alpha }) => {
	if (h === void 0) h = 0;
	let res = {
		mode: "luv",
		l,
		u: c$1 ? c$1 * Math.cos(h / 180 * Math.PI) : 0,
		v: c$1 ? c$1 * Math.sin(h / 180 * Math.PI) : 0
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLchuvToLuv_default = convertLchuvToLuv;

//#endregion
//#region node_modules/culori/src/luv/convertXyz50ToLuv.js
const u_fn$1 = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn$1 = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un$1 = u_fn$1(D50.X, D50.Y, D50.Z);
const vn$1 = v_fn$1(D50.X, D50.Y, D50.Z);
var l_fn = (value) => value <= e ? k * value : 116 * Math.cbrt(value) - 16;
var convertXyz50ToLuv = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let l = l_fn(y / D50.Y);
	let u = u_fn$1(x, y, z);
	let v = v_fn$1(x, y, z);
	if (!isFinite(u) || !isFinite(v)) l = u = v = 0;
	else {
		u = 13 * l * (u - un$1);
		v = 13 * l * (v - vn$1);
	}
	let res = {
		mode: "luv",
		l,
		u,
		v
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToLuv_default = convertXyz50ToLuv;

//#endregion
//#region node_modules/culori/src/luv/convertLuvToXyz50.js
const u_fn = (x, y, z) => 4 * x / (x + 15 * y + 3 * z);
const v_fn = (x, y, z) => 9 * y / (x + 15 * y + 3 * z);
const un = u_fn(D50.X, D50.Y, D50.Z);
const vn = v_fn(D50.X, D50.Y, D50.Z);
var convertLuvToXyz50 = ({ l, u, v, alpha }) => {
	if (l === void 0) l = 0;
	if (l === 0) return {
		mode: "xyz50",
		x: 0,
		y: 0,
		z: 0
	};
	if (u === void 0) u = 0;
	if (v === void 0) v = 0;
	let up = u / (13 * l) + un;
	let vp = v / (13 * l) + vn;
	let y = D50.Y * (l <= 8 ? l / k : Math.pow((l + 16) / 116, 3));
	let res = {
		mode: "xyz50",
		x: y * (9 * up) / (4 * vp),
		y,
		z: y * (12 - 3 * up - 20 * vp) / (4 * vp)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLuvToXyz50_default = convertLuvToXyz50;

//#endregion
//#region node_modules/culori/src/lchuv/definition.js
var convertRgbToLchuv = (rgb$4) => convertLuvToLchuv_default(convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb$4)));
var convertLchuvToRgb = (lchuv$1) => convertXyz50ToRgb_default(convertLuvToXyz50_default(convertLchuvToLuv_default(lchuv$1)));
var definition$11 = {
	mode: "lchuv",
	toMode: {
		luv: convertLchuvToLuv_default,
		rgb: convertLchuvToRgb
	},
	fromMode: {
		rgb: convertRgbToLchuv,
		luv: convertLuvToLchuv_default
	},
	channels: [
		"l",
		"c",
		"h",
		"alpha"
	],
	parse: ["--lchuv"],
	serialize: "--lchuv",
	ranges: {
		l: [0, 100],
		c: [0, 176.956],
		h: [0, 360]
	},
	interpolate: {
		h: {
			use: interpolatorLinear,
			fixup: fixupHueShorter
		},
		c: interpolatorLinear,
		l: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	},
	difference: { h: differenceHueChroma },
	average: { h: averageAngle }
};
var definition_default$15 = definition$11;

//#endregion
//#region node_modules/culori/src/lrgb/definition.js
var definition$10 = {
	...definition_default$23,
	mode: "lrgb",
	toMode: { rgb: convertLrgbToRgb_default },
	fromMode: { rgb: convertRgbToLrgb_default },
	parse: ["srgb-linear"],
	serialize: "srgb-linear"
};
var definition_default$16 = definition$10;

//#endregion
//#region node_modules/culori/src/luv/definition.js
var definition$9 = {
	mode: "luv",
	toMode: {
		xyz50: convertLuvToXyz50_default,
		rgb: (luv$1) => convertXyz50ToRgb_default(convertLuvToXyz50_default(luv$1))
	},
	fromMode: {
		xyz50: convertXyz50ToLuv_default,
		rgb: (rgb$4) => convertXyz50ToLuv_default(convertRgbToXyz50_default(rgb$4))
	},
	channels: [
		"l",
		"u",
		"v",
		"alpha"
	],
	parse: ["--luv"],
	serialize: "--luv",
	ranges: {
		l: [0, 100],
		u: [-84.936, 175.042],
		v: [-125.882, 87.243]
	},
	interpolate: {
		l: interpolatorLinear,
		u: interpolatorLinear,
		v: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$17 = definition$9;

//#endregion
//#region node_modules/culori/src/oklab/convertLrgbToOklab.js
var convertLrgbToOklab = ({ r: r$1, g, b, alpha }) => {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	let L = Math.cbrt(.412221469470763 * r$1 + .5363325372617348 * g + .0514459932675022 * b);
	let M$1 = Math.cbrt(.2119034958178252 * r$1 + .6806995506452344 * g + .1073969535369406 * b);
	let S = Math.cbrt(.0883024591900564 * r$1 + .2817188391361215 * g + .6299787016738222 * b);
	let res = {
		mode: "oklab",
		l: .210454268309314 * L + .7936177747023054 * M$1 - .0040720430116193 * S,
		a: 1.9779985324311684 * L - 2.42859224204858 * M$1 + .450593709617411 * S,
		b: .0259040424655478 * L + .7827717124575296 * M$1 - .8086757549230774 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertLrgbToOklab_default = convertLrgbToOklab;

//#endregion
//#region node_modules/culori/src/oklab/convertRgbToOklab.js
var convertRgbToOklab = (rgb$4) => {
	let res = convertLrgbToOklab_default(convertRgbToLrgb_default(rgb$4));
	if (rgb$4.r === rgb$4.b && rgb$4.b === rgb$4.g) res.a = res.b = 0;
	return res;
};
var convertRgbToOklab_default = convertRgbToOklab;

//#endregion
//#region node_modules/culori/src/oklab/convertOklabToLrgb.js
var convertOklabToLrgb = ({ l, a, b, alpha }) => {
	if (l === void 0) l = 0;
	if (a === void 0) a = 0;
	if (b === void 0) b = 0;
	let L = Math.pow(l + .3963377773761749 * a + .2158037573099136 * b, 3);
	let M$1 = Math.pow(l - .1055613458156586 * a - .0638541728258133 * b, 3);
	let S = Math.pow(l - .0894841775298119 * a - 1.2914855480194092 * b, 3);
	let res = {
		mode: "lrgb",
		r: 4.076741636075957 * L - 3.3077115392580616 * M$1 + .2309699031821044 * S,
		g: -1.2684379732850317 * L + 2.6097573492876887 * M$1 - .3413193760026573 * S,
		b: -.0041960761386756 * L - .7034186179359362 * M$1 + 1.7076146940746117 * S
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertOklabToLrgb_default = convertOklabToLrgb;

//#endregion
//#region node_modules/culori/src/oklab/convertOklabToRgb.js
var convertOklabToRgb = (c$1) => convertLrgbToRgb_default(convertOklabToLrgb_default(c$1));
var convertOklabToRgb_default = convertOklabToRgb;

//#endregion
//#region node_modules/culori/src/okhsl/helpers.js
function toe(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return .5 * (k_3 * x - k_1 + Math.sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4 * k_2 * k_3 * x));
}
function toe_inv(x) {
	const k_1 = .206;
	const k_2 = .03;
	const k_3 = (1 + k_1) / (1 + k_2);
	return (x * x + k_1 * x) / (k_3 * (x + k_2));
}
function compute_max_saturation(a, b) {
	let k0, k1, k2, k3, k4, wl, wm, ws;
	if (-1.88170328 * a - .80936493 * b > 1) {
		k0 = 1.19086277;
		k1 = 1.76576728;
		k2 = .59662641;
		k3 = .75515197;
		k4 = .56771245;
		wl = 4.0767416621;
		wm = -3.3077115913;
		ws = .2309699292;
	} else if (1.81444104 * a - 1.19445276 * b > 1) {
		k0 = .73956515;
		k1 = -.45954404;
		k2 = .08285427;
		k3 = .1254107;
		k4 = .14503204;
		wl = -1.2684380046;
		wm = 2.6097574011;
		ws = -.3413193965;
	} else {
		k0 = 1.35733652;
		k1 = -.00915799;
		k2 = -1.1513021;
		k3 = -.50559606;
		k4 = .00692167;
		wl = -.0041960863;
		wm = -.7034186147;
		ws = 1.707614701;
	}
	let S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;
	let k_l = .3963377774 * a + .2158037573 * b;
	let k_m = -.1055613458 * a - .0638541728 * b;
	let k_s = -.0894841775 * a - 1.291485548 * b;
	{
		let l_ = 1 + S * k_l;
		let m_ = 1 + S * k_m;
		let s_ = 1 + S * k_s;
		let l = l_ * l_ * l_;
		let m = m_ * m_ * m_;
		let s = s_ * s_ * s_;
		let l_dS = 3 * k_l * l_ * l_;
		let m_dS = 3 * k_m * m_ * m_;
		let s_dS = 3 * k_s * s_ * s_;
		let l_dS2 = 6 * k_l * k_l * l_;
		let m_dS2 = 6 * k_m * k_m * m_;
		let s_dS2 = 6 * k_s * k_s * s_;
		let f$2 = wl * l + wm * m + ws * s;
		let f1 = wl * l_dS + wm * m_dS + ws * s_dS;
		let f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
		S = S - f$2 * f1 / (f1 * f1 - .5 * f$2 * f2);
	}
	return S;
}
function find_cusp(a, b) {
	let S_cusp = compute_max_saturation(a, b);
	let rgb$4 = convertOklabToLrgb_default({
		l: 1,
		a: S_cusp * a,
		b: S_cusp * b
	});
	let L_cusp = Math.cbrt(1 / Math.max(rgb$4.r, rgb$4.g, rgb$4.b));
	return [L_cusp, L_cusp * S_cusp];
}
function find_gamut_intersection(a, b, L1, C1$1, L0, cusp = null) {
	if (!cusp) cusp = find_cusp(a, b);
	let t;
	if ((L1 - L0) * cusp[1] - (cusp[0] - L0) * C1$1 <= 0) t = cusp[1] * L0 / (C1$1 * cusp[0] + cusp[1] * (L0 - L1));
	else {
		t = cusp[1] * (L0 - 1) / (C1$1 * (cusp[0] - 1) + cusp[1] * (L0 - L1));
		{
			let dL = L1 - L0;
			let dC = C1$1;
			let k_l = .3963377774 * a + .2158037573 * b;
			let k_m = -.1055613458 * a - .0638541728 * b;
			let k_s = -.0894841775 * a - 1.291485548 * b;
			let l_dt = dL + dC * k_l;
			let m_dt = dL + dC * k_m;
			let s_dt = dL + dC * k_s;
			{
				let L = L0 * (1 - t) + t * L1;
				let C = t * C1$1;
				let l_ = L + C * k_l;
				let m_ = L + C * k_m;
				let s_ = L + C * k_s;
				let l = l_ * l_ * l_;
				let m = m_ * m_ * m_;
				let s = s_ * s_ * s_;
				let ldt = 3 * l_dt * l_ * l_;
				let mdt = 3 * m_dt * m_ * m_;
				let sdt = 3 * s_dt * s_ * s_;
				let ldt2 = 6 * l_dt * l_dt * l_;
				let mdt2 = 6 * m_dt * m_dt * m_;
				let sdt2 = 6 * s_dt * s_dt * s_;
				let r$1 = 4.0767416621 * l - 3.3077115913 * m + .2309699292 * s - 1;
				let r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + .2309699292 * sdt;
				let r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + .2309699292 * sdt2;
				let u_r = r1 / (r1 * r1 - .5 * r$1 * r2);
				let t_r = -r$1 * u_r;
				let g = -1.2684380046 * l + 2.6097574011 * m - .3413193965 * s - 1;
				let g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - .3413193965 * sdt;
				let g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - .3413193965 * sdt2;
				let u_g = g1 / (g1 * g1 - .5 * g * g2);
				let t_g = -g * u_g;
				let b$1 = -.0041960863 * l - .7034186147 * m + 1.707614701 * s - 1;
				let b1 = -.0041960863 * ldt - .7034186147 * mdt + 1.707614701 * sdt;
				let b2 = -.0041960863 * ldt2 - .7034186147 * mdt2 + 1.707614701 * sdt2;
				let u_b = b1 / (b1 * b1 - .5 * b$1 * b2);
				let t_b = -b$1 * u_b;
				t_r = u_r >= 0 ? t_r : 1e6;
				t_g = u_g >= 0 ? t_g : 1e6;
				t_b = u_b >= 0 ? t_b : 1e6;
				t += Math.min(t_r, Math.min(t_g, t_b));
			}
		}
	}
	return t;
}
function get_ST_max(a_, b_, cusp = null) {
	if (!cusp) cusp = find_cusp(a_, b_);
	let L = cusp[0];
	let C = cusp[1];
	return [C / L, C / (1 - L)];
}
function get_Cs(L, a_, b_) {
	let cusp = find_cusp(a_, b_);
	let C_max = find_gamut_intersection(a_, b_, L, 1, L, cusp);
	let ST_max = get_ST_max(a_, b_, cusp);
	let S_mid = .11516993 + 1 / (7.4477897 + 4.1590124 * b_ + a_ * (-2.19557347 + 1.75198401 * b_ + a_ * (-2.13704948 - 10.02301043 * b_ + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_))));
	let T_mid = .11239642 + 1 / (1.6132032 - .68124379 * b_ + a_ * (.40370612 + .90148123 * b_ + a_ * (-.27087943 + .6122399 * b_ + a_ * (.00299215 - .45399568 * b_ - .14661872 * a_))));
	let k$3 = C_max / Math.min(L * ST_max[0], (1 - L) * ST_max[1]);
	let C_a = L * S_mid;
	let C_b = (1 - L) * T_mid;
	let C_mid = .9 * k$3 * Math.sqrt(Math.sqrt(1 / (1 / (C_a * C_a * C_a * C_a) + 1 / (C_b * C_b * C_b * C_b))));
	C_a = L * .4;
	C_b = (1 - L) * .8;
	return [
		Math.sqrt(1 / (1 / (C_a * C_a) + 1 / (C_b * C_b))),
		C_mid,
		C_max
	];
}

//#endregion
//#region node_modules/culori/src/okhsl/convertOklabToOkhsl.js
function convertOklabToOkhsl(lab$1) {
	const l = lab$1.l !== void 0 ? lab$1.l : 0;
	const a = lab$1.a !== void 0 ? lab$1.a : 0;
	const b = lab$1.b !== void 0 ? lab$1.b : 0;
	const ret = {
		mode: "okhsl",
		l: toe(l)
	};
	if (lab$1.alpha !== void 0) ret.alpha = lab$1.alpha;
	let c$1 = Math.sqrt(a * a + b * b);
	if (!c$1) {
		ret.s = 0;
		return ret;
	}
	let [C_0, C_mid, C_max] = get_Cs(l, a / c$1, b / c$1);
	let s;
	if (c$1 < C_mid) {
		let k_0 = 0;
		let k_1 = .8 * C_0;
		let k_2 = 1 - k_1 / C_mid;
		s = (c$1 - k_0) / (k_1 + k_2 * (c$1 - k_0)) * .8;
	} else {
		let k_0 = C_mid;
		let k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		let k_2 = 1 - k_1 / (C_max - C_mid);
		s = .8 + .2 * ((c$1 - k_0) / (k_1 + k_2 * (c$1 - k_0)));
	}
	if (s) {
		ret.s = s;
		ret.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	}
	return ret;
}

//#endregion
//#region node_modules/culori/src/okhsl/convertOkhslToOklab.js
function convertOkhslToOklab(hsl$2) {
	let h = hsl$2.h !== void 0 ? hsl$2.h : 0;
	let s = hsl$2.s !== void 0 ? hsl$2.s : 0;
	let l = hsl$2.l !== void 0 ? hsl$2.l : 0;
	const ret = {
		mode: "oklab",
		l: toe_inv(l)
	};
	if (hsl$2.alpha !== void 0) ret.alpha = hsl$2.alpha;
	if (!s || l === 1) {
		ret.a = ret.b = 0;
		return ret;
	}
	let a_ = Math.cos(h / 180 * Math.PI);
	let b_ = Math.sin(h / 180 * Math.PI);
	let [C_0, C_mid, C_max] = get_Cs(ret.l, a_, b_);
	let t, k_0, k_1, k_2;
	if (s < .8) {
		t = 1.25 * s;
		k_0 = 0;
		k_1 = .8 * C_0;
		k_2 = 1 - k_1 / C_mid;
	} else {
		t = 5 * (s - .8);
		k_0 = C_mid;
		k_1 = .2 * C_mid * C_mid * 1.25 * 1.25 / C_0;
		k_2 = 1 - k_1 / (C_max - C_mid);
	}
	let C = k_0 + t * k_1 / (1 - k_2 * t);
	ret.a = C * a_;
	ret.b = C * b_;
	return ret;
}

//#endregion
//#region node_modules/culori/src/okhsl/modeOkhsl.js
var modeOkhsl = {
	...definition_default$5,
	mode: "okhsl",
	channels: [
		"h",
		"s",
		"l",
		"alpha"
	],
	parse: ["--okhsl"],
	serialize: "--okhsl",
	fromMode: {
		oklab: convertOklabToOkhsl,
		rgb: (c$1) => convertOklabToOkhsl(convertRgbToOklab_default(c$1))
	},
	toMode: {
		oklab: convertOkhslToOklab,
		rgb: (c$1) => convertOklabToRgb_default(convertOkhslToOklab(c$1))
	}
};
var modeOkhsl_default = modeOkhsl;

//#endregion
//#region node_modules/culori/src/okhsv/convertOklabToOkhsv.js
function convertOklabToOkhsv(lab$1) {
	let l = lab$1.l !== void 0 ? lab$1.l : 0;
	let a = lab$1.a !== void 0 ? lab$1.a : 0;
	let b = lab$1.b !== void 0 ? lab$1.b : 0;
	let c$1 = Math.sqrt(a * a + b * b);
	let a_ = c$1 ? a / c$1 : 1;
	let b_ = c$1 ? b / c$1 : 1;
	let [S_max, T] = get_ST_max(a_, b_);
	let S_0 = .5;
	let k$3 = 1 - S_0 / S_max;
	let t = T / (c$1 + l * T);
	let L_v = t * l;
	let C_v = t * c$1;
	let L_vt = toe_inv(L_v);
	let C_vt = C_v * L_vt / L_v;
	let rgb_scale = convertOklabToLrgb_default({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	let scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	l = l / scale_L;
	c$1 = c$1 / scale_L * toe(l) / l;
	l = toe(l);
	const ret = {
		mode: "okhsv",
		s: c$1 ? (S_0 + T) * C_v / (T * S_0 + T * k$3 * C_v) : 0,
		v: l ? l / L_v : 0
	};
	if (ret.s) ret.h = normalizeHue_default(Math.atan2(b, a) * 180 / Math.PI);
	if (lab$1.alpha !== void 0) ret.alpha = lab$1.alpha;
	return ret;
}

//#endregion
//#region node_modules/culori/src/okhsv/convertOkhsvToOklab.js
function convertOkhsvToOklab(hsv$1) {
	const ret = { mode: "oklab" };
	if (hsv$1.alpha !== void 0) ret.alpha = hsv$1.alpha;
	const h = hsv$1.h !== void 0 ? hsv$1.h : 0;
	const s = hsv$1.s !== void 0 ? hsv$1.s : 0;
	const v = hsv$1.v !== void 0 ? hsv$1.v : 0;
	const a_ = Math.cos(h / 180 * Math.PI);
	const b_ = Math.sin(h / 180 * Math.PI);
	const [S_max, T] = get_ST_max(a_, b_);
	const S_0 = .5;
	const k$3 = 1 - S_0 / S_max;
	const L_v = 1 - s * S_0 / (S_0 + T - T * k$3 * s);
	const C_v = s * T * S_0 / (S_0 + T - T * k$3 * s);
	const L_vt = toe_inv(L_v);
	const C_vt = C_v * L_vt / L_v;
	const rgb_scale = convertOklabToLrgb_default({
		l: L_vt,
		a: a_ * C_vt,
		b: b_ * C_vt
	});
	const scale_L = Math.cbrt(1 / Math.max(rgb_scale.r, rgb_scale.g, rgb_scale.b, 0));
	const L_new = toe_inv(v * L_v);
	const C = C_v * L_new / L_v;
	ret.l = L_new * scale_L;
	ret.a = C * a_ * scale_L;
	ret.b = C * b_ * scale_L;
	return ret;
}

//#endregion
//#region node_modules/culori/src/okhsv/modeOkhsv.js
var modeOkhsv = {
	...definition_default$6,
	mode: "okhsv",
	channels: [
		"h",
		"s",
		"v",
		"alpha"
	],
	parse: ["--okhsv"],
	serialize: "--okhsv",
	fromMode: {
		oklab: convertOklabToOkhsv,
		rgb: (c$1) => convertOklabToOkhsv(convertRgbToOklab_default(c$1))
	},
	toMode: {
		oklab: convertOkhsvToOklab,
		rgb: (c$1) => convertOklabToRgb_default(convertOkhsvToOklab(c$1))
	}
};
var modeOkhsv_default = modeOkhsv;

//#endregion
//#region node_modules/culori/src/oklab/parseOklab.js
function parseOklab(color, parsed) {
	if (!parsed || parsed[0] !== "oklab") return;
	const res = { mode: "oklab" };
	const [, l, a, b, alpha] = parsed;
	if (l.type === Tok.Hue || a.type === Tok.Hue || b.type === Tok.Hue) return;
	if (l.type !== Tok.None) res.l = Math.min(Math.max(0, l.type === Tok.Number ? l.value : l.value / 100), 1);
	if (a.type !== Tok.None) res.a = a.type === Tok.Number ? a.value : a.value * .4 / 100;
	if (b.type !== Tok.None) res.b = b.type === Tok.Number ? b.value : b.value * .4 / 100;
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklab_default = parseOklab;

//#endregion
//#region node_modules/culori/src/oklab/definition.js
var definition$8 = {
	...definition_default$11,
	mode: "oklab",
	toMode: {
		lrgb: convertOklabToLrgb_default,
		rgb: convertOklabToRgb_default
	},
	fromMode: {
		lrgb: convertLrgbToOklab_default,
		rgb: convertRgbToOklab_default
	},
	ranges: {
		l: [0, 1],
		a: [-.4, .4],
		b: [-.4, .4]
	},
	parse: [parseOklab_default],
	serialize: (c$1) => `oklab(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.a !== void 0 ? c$1.a : "none"} ${c$1.b !== void 0 ? c$1.b : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`
};
var definition_default$18 = definition$8;

//#endregion
//#region node_modules/culori/src/oklch/parseOklch.js
function parseOklch(color, parsed) {
	if (!parsed || parsed[0] !== "oklch") return;
	const res = { mode: "oklch" };
	const [, l, c$1, h, alpha] = parsed;
	if (l.type !== Tok.None) {
		if (l.type === Tok.Hue) return;
		res.l = Math.min(Math.max(0, l.type === Tok.Number ? l.value : l.value / 100), 1);
	}
	if (c$1.type !== Tok.None) res.c = Math.max(0, c$1.type === Tok.Number ? c$1.value : c$1.value * .4 / 100);
	if (h.type !== Tok.None) {
		if (h.type === Tok.Percentage) return;
		res.h = h.value;
	}
	if (alpha.type !== Tok.None) res.alpha = Math.min(1, Math.max(0, alpha.type === Tok.Number ? alpha.value : alpha.value / 100));
	return res;
}
var parseOklch_default = parseOklch;

//#endregion
//#region node_modules/culori/src/oklch/definition.js
var definition$7 = {
	...definition_default$13,
	mode: "oklch",
	toMode: {
		oklab: (c$1) => convertLchToLab_default(c$1, "oklab"),
		rgb: (c$1) => convertOklabToRgb_default(convertLchToLab_default(c$1, "oklab"))
	},
	fromMode: {
		rgb: (c$1) => convertLabToLch_default(convertRgbToOklab_default(c$1), "oklch"),
		oklab: (c$1) => convertLabToLch_default(c$1, "oklch")
	},
	parse: [parseOklch_default],
	serialize: (c$1) => `oklch(${c$1.l !== void 0 ? c$1.l : "none"} ${c$1.c !== void 0 ? c$1.c : "none"} ${c$1.h !== void 0 ? c$1.h : "none"}${c$1.alpha < 1 ? ` / ${c$1.alpha}` : ""})`,
	ranges: {
		l: [0, 1],
		c: [0, .4],
		h: [0, 360]
	}
};
var definition_default$19 = definition$7;

//#endregion
//#region node_modules/culori/src/p3/convertP3ToXyz65.js
var convertP3ToXyz65 = (rgb$4) => {
	let { r: r$1, g, b, alpha } = convertRgbToLrgb_default(rgb$4);
	let res = {
		mode: "xyz65",
		x: .486570948648216 * r$1 + .265667693169093 * g + .1982172852343625 * b,
		y: .2289745640697487 * r$1 + .6917385218365062 * g + .079286914093745 * b,
		z: 0 * r$1 + .0451133818589026 * g + 1.043944368900976 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertP3ToXyz65_default = convertP3ToXyz65;

//#endregion
//#region node_modules/culori/src/p3/convertXyz65ToP3.js
var convertXyz65ToP3 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = convertLrgbToRgb_default({
		r: x * 2.4934969119414263 - y * .9313836179191242 - .402710784450717 * z,
		g: x * -.8294889695615749 + y * 1.7626640603183465 + .0236246858419436 * z,
		b: x * .0358458302437845 - y * .0761723892680418 + .9568845240076871 * z
	}, "p3");
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToP3_default = convertXyz65ToP3;

//#endregion
//#region node_modules/culori/src/p3/definition.js
var definition$6 = {
	...definition_default$23,
	mode: "p3",
	parse: ["display-p3"],
	serialize: "display-p3",
	fromMode: {
		rgb: (color) => convertXyz65ToP3_default(convertRgbToXyz65_default(color)),
		xyz65: convertXyz65ToP3_default
	},
	toMode: {
		rgb: (color) => convertXyz65ToRgb_default(convertP3ToXyz65_default(color)),
		xyz65: convertP3ToXyz65_default
	}
};
var definition_default$20 = definition$6;

//#endregion
//#region node_modules/culori/src/prophoto/convertXyz50ToProphoto.js
var gamma$2 = (v) => {
	let abs$2 = Math.abs(v);
	if (abs$2 >= 1 / 512) return Math.sign(v) * Math.pow(abs$2, 1 / 1.8);
	return 16 * v;
};
var convertXyz50ToProphoto = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "prophoto",
		r: gamma$2(x * 1.3457868816471585 - y * .2555720873797946 - .0511018649755453 * z),
		g: gamma$2(x * -.5446307051249019 + y * 1.5082477428451466 + .0205274474364214 * z),
		b: gamma$2(x * 0 + y * 0 + 1.2119675456389452 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToProphoto_default = convertXyz50ToProphoto;

//#endregion
//#region node_modules/culori/src/prophoto/convertProphotoToXyz50.js
var linearize$1 = (v = 0) => {
	let abs$2 = Math.abs(v);
	if (abs$2 >= 16 / 512) return Math.sign(v) * Math.pow(abs$2, 1.8);
	return v / 16;
};
var convertProphotoToXyz50 = (prophoto$1) => {
	let r$1 = linearize$1(prophoto$1.r);
	let g = linearize$1(prophoto$1.g);
	let b = linearize$1(prophoto$1.b);
	let res = {
		mode: "xyz50",
		x: .7977666449006423 * r$1 + .1351812974005331 * g + .0313477341283922 * b,
		y: .2880748288194013 * r$1 + .7118352342418731 * g + 899369387256e-16 * b,
		z: 0 * r$1 + 0 * g + .8251046025104602 * b
	};
	if (prophoto$1.alpha !== void 0) res.alpha = prophoto$1.alpha;
	return res;
};
var convertProphotoToXyz50_default = convertProphotoToXyz50;

//#endregion
//#region node_modules/culori/src/prophoto/definition.js
var definition$5 = {
	...definition_default$23,
	mode: "prophoto",
	parse: ["prophoto-rgb"],
	serialize: "prophoto-rgb",
	fromMode: {
		xyz50: convertXyz50ToProphoto_default,
		rgb: (color) => convertXyz50ToProphoto_default(convertRgbToXyz50_default(color))
	},
	toMode: {
		xyz50: convertProphotoToXyz50_default,
		rgb: (color) => convertXyz50ToRgb_default(convertProphotoToXyz50_default(color))
	}
};
var definition_default$21 = definition$5;

//#endregion
//#region node_modules/culori/src/rec2020/convertXyz65ToRec2020.js
var α$1 = 1.09929682680944;
var β$1 = .018053968510807;
var gamma$1 = (v) => {
	const abs$2 = Math.abs(v);
	if (abs$2 > β$1) return (Math.sign(v) || 1) * (α$1 * Math.pow(abs$2, .45) - (α$1 - 1));
	return 4.5 * v;
};
var convertXyz65ToRec2020 = ({ x, y, z, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "rec2020",
		r: gamma$1(x * 1.7166511879712683 - y * .3556707837763925 - .2533662813736599 * z),
		g: gamma$1(x * -.6666843518324893 + y * 1.6164812366349395 + .0157685458139111 * z),
		b: gamma$1(x * .0176398574453108 - y * .0427706132578085 + .9421031212354739 * z)
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToRec2020_default = convertXyz65ToRec2020;

//#endregion
//#region node_modules/culori/src/rec2020/convertRec2020ToXyz65.js
var α = 1.09929682680944;
var β = .018053968510807;
var linearize = (v = 0) => {
	let abs$2 = Math.abs(v);
	if (abs$2 < β * 4.5) return v / 4.5;
	return (Math.sign(v) || 1) * Math.pow((abs$2 + α - 1) / α, 1 / .45);
};
var convertRec2020ToXyz65 = (rec2020$1) => {
	let r$1 = linearize(rec2020$1.r);
	let g = linearize(rec2020$1.g);
	let b = linearize(rec2020$1.b);
	let res = {
		mode: "xyz65",
		x: .6369580483012911 * r$1 + .1446169035862083 * g + .1688809751641721 * b,
		y: .262700212011267 * r$1 + .6779980715188708 * g + .059301716469862 * b,
		z: 0 * r$1 + .0280726930490874 * g + 1.0609850577107909 * b
	};
	if (rec2020$1.alpha !== void 0) res.alpha = rec2020$1.alpha;
	return res;
};
var convertRec2020ToXyz65_default = convertRec2020ToXyz65;

//#endregion
//#region node_modules/culori/src/rec2020/definition.js
var definition$4 = {
	...definition_default$23,
	mode: "rec2020",
	fromMode: {
		xyz65: convertXyz65ToRec2020_default,
		rgb: (color) => convertXyz65ToRec2020_default(convertRgbToXyz65_default(color))
	},
	toMode: {
		xyz65: convertRec2020ToXyz65_default,
		rgb: (color) => convertXyz65ToRgb_default(convertRec2020ToXyz65_default(color))
	},
	parse: ["rec2020"],
	serialize: "rec2020"
};
var definition_default$22 = definition$4;

//#endregion
//#region node_modules/culori/src/xyb/constants.js
const bias = .0037930732552754493;
const bias_cbrt = Math.cbrt(bias);

//#endregion
//#region node_modules/culori/src/xyb/convertRgbToXyb.js
var transfer$1 = (v) => Math.cbrt(v) - bias_cbrt;
var convertRgbToXyb = (color) => {
	const { r: r$1, g, b, alpha } = convertRgbToLrgb_default(color);
	const l = transfer$1(.3 * r$1 + .622 * g + .078 * b + bias);
	const m = transfer$1(.23 * r$1 + .692 * g + .078 * b + bias);
	const s = transfer$1(.2434226892454782 * r$1 + .2047674442449682 * g + .5518098665095535 * b + bias);
	const res = {
		mode: "xyb",
		x: (l - m) / 2,
		y: (l + m) / 2,
		b: s - (l + m) / 2
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToXyb_default = convertRgbToXyb;

//#endregion
//#region node_modules/culori/src/xyb/convertXybToRgb.js
var transfer = (v) => Math.pow(v + bias_cbrt, 3);
var convertXybToRgb = ({ x, y, b, alpha }) => {
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (b === void 0) b = 0;
	const l = transfer(x + y) - bias;
	const m = transfer(y - x) - bias;
	const s = transfer(b + y) - bias;
	const res = convertLrgbToRgb_default({
		r: 11.031566904639861 * l - 9.866943908131562 * m - .16462299650829934 * s,
		g: -3.2541473810744237 * l + 4.418770377582723 * m - .16462299650829934 * s,
		b: -3.6588512867136815 * l + 2.7129230459360922 * m + 1.9459282407775895 * s
	});
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXybToRgb_default = convertXybToRgb;

//#endregion
//#region node_modules/culori/src/xyb/definition.js
var definition$3 = {
	mode: "xyb",
	channels: [
		"x",
		"y",
		"b",
		"alpha"
	],
	parse: ["--xyb"],
	serialize: "--xyb",
	toMode: { rgb: convertXybToRgb_default },
	fromMode: { rgb: convertRgbToXyb_default },
	ranges: {
		x: [-.0154, .0281],
		y: [0, .8453],
		b: [-.2778, .388]
	},
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		b: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$24 = definition$3;

//#endregion
//#region node_modules/culori/src/xyz50/definition.js
var definition$2 = {
	mode: "xyz50",
	parse: ["xyz-d50"],
	serialize: "xyz-d50",
	toMode: {
		rgb: convertXyz50ToRgb_default,
		lab: convertXyz50ToLab_default
	},
	fromMode: {
		rgb: convertRgbToXyz50_default,
		lab: convertLabToXyz50_default
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	ranges: {
		x: [0, .964],
		y: [0, .999],
		z: [0, .825]
	},
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		z: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$25 = definition$2;

//#endregion
//#region node_modules/culori/src/xyz65/convertXyz65ToXyz50.js
var convertXyz65ToXyz50 = (xyz65$1) => {
	let { x, y, z, alpha } = xyz65$1;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz50",
		x: 1.0479298208405488 * x + .0229467933410191 * y - .0501922295431356 * z,
		y: .0296278156881593 * x + .990434484573249 * y - .0170738250293851 * z,
		z: -.0092430581525912 * x + .0150551448965779 * y + .7518742899580008 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz65ToXyz50_default = convertXyz65ToXyz50;

//#endregion
//#region node_modules/culori/src/xyz65/convertXyz50ToXyz65.js
var convertXyz50ToXyz65 = (xyz50$1) => {
	let { x, y, z, alpha } = xyz50$1;
	if (x === void 0) x = 0;
	if (y === void 0) y = 0;
	if (z === void 0) z = 0;
	let res = {
		mode: "xyz65",
		x: .9554734527042182 * x - .0230985368742614 * y + .0632593086610217 * z,
		y: -.0283697069632081 * x + 1.0099954580058226 * y + .021041398966943 * z,
		z: .0123140016883199 * x - .0205076964334779 * y + 1.3303659366080753 * z
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertXyz50ToXyz65_default = convertXyz50ToXyz65;

//#endregion
//#region node_modules/culori/src/xyz65/definition.js
var definition$1 = {
	mode: "xyz65",
	toMode: {
		rgb: convertXyz65ToRgb_default,
		xyz50: convertXyz65ToXyz50_default
	},
	fromMode: {
		rgb: convertRgbToXyz65_default,
		xyz50: convertXyz50ToXyz65_default
	},
	ranges: {
		x: [0, .95],
		y: [0, 1],
		z: [0, 1.088]
	},
	channels: [
		"x",
		"y",
		"z",
		"alpha"
	],
	parse: ["xyz", "xyz-d65"],
	serialize: "xyz-d65",
	interpolate: {
		x: interpolatorLinear,
		y: interpolatorLinear,
		z: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$26 = definition$1;

//#endregion
//#region node_modules/culori/src/yiq/convertRgbToYiq.js
var convertRgbToYiq = ({ r: r$1, g, b, alpha }) => {
	if (r$1 === void 0) r$1 = 0;
	if (g === void 0) g = 0;
	if (b === void 0) b = 0;
	const res = {
		mode: "yiq",
		y: .29889531 * r$1 + .58662247 * g + .11448223 * b,
		i: .59597799 * r$1 - .2741761 * g - .32180189 * b,
		q: .21147017 * r$1 - .52261711 * g + .31114694 * b
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertRgbToYiq_default = convertRgbToYiq;

//#endregion
//#region node_modules/culori/src/yiq/convertYiqToRgb.js
var convertYiqToRgb = ({ y, i, q, alpha }) => {
	if (y === void 0) y = 0;
	if (i === void 0) i = 0;
	if (q === void 0) q = 0;
	const res = {
		mode: "rgb",
		r: y + .95608445 * i + .6208885 * q,
		g: y - .27137664 * i - .6486059 * q,
		b: y - 1.10561724 * i + 1.70250126 * q
	};
	if (alpha !== void 0) res.alpha = alpha;
	return res;
};
var convertYiqToRgb_default = convertYiqToRgb;

//#endregion
//#region node_modules/culori/src/yiq/definition.js
var definition = {
	mode: "yiq",
	toMode: { rgb: convertYiqToRgb_default },
	fromMode: { rgb: convertRgbToYiq_default },
	channels: [
		"y",
		"i",
		"q",
		"alpha"
	],
	parse: ["--yiq"],
	serialize: "--yiq",
	ranges: {
		i: [-.595, .595],
		q: [-.522, .522]
	},
	interpolate: {
		y: interpolatorLinear,
		i: interpolatorLinear,
		q: interpolatorLinear,
		alpha: {
			use: interpolatorLinear,
			fixup: fixupAlpha
		}
	}
};
var definition_default$27 = definition;

//#endregion
//#region node_modules/culori/src/round.js
var r = (value, precision) => Math.round(value * (precision = Math.pow(10, precision))) / precision;
var round = (precision = 4) => (value) => typeof value === "number" ? r(value, precision) : value;
var round_default = round;

//#endregion
//#region node_modules/culori/src/formatter.js
var twoDecimals = round_default(2);
var clamp$1 = (value) => Math.max(0, Math.min(1, value || 0));
var fixup = (value) => Math.round(clamp$1(value) * 255);
var rgb$3 = converter_default("rgb");
var hsl$1 = converter_default("hsl");
const serializeHex = (color) => {
	if (color === void 0) return;
	let r$1 = fixup(color.r);
	let g = fixup(color.g);
	let b = fixup(color.b);
	return "#" + (1 << 24 | r$1 << 16 | g << 8 | b).toString(16).slice(1);
};
const serializeHex8 = (color) => {
	if (color === void 0) return;
	let a = fixup(color.alpha !== void 0 ? color.alpha : 1);
	return serializeHex(color) + (256 | a).toString(16).slice(1);
};
const serializeRgb = (color) => {
	if (color === void 0) return;
	let r$1 = fixup(color.r);
	let g = fixup(color.g);
	let b = fixup(color.b);
	if (color.alpha === void 0 || color.alpha === 1) return `rgb(${r$1}, ${g}, ${b})`;
	else return `rgba(${r$1}, ${g}, ${b}, ${twoDecimals(clamp$1(color.alpha))})`;
};
const serializeHsl = (color) => {
	if (color === void 0) return;
	const h = twoDecimals(color.h || 0);
	const s = twoDecimals(clamp$1(color.s) * 100) + "%";
	const l = twoDecimals(clamp$1(color.l) * 100) + "%";
	if (color.alpha === void 0 || color.alpha === 1) return `hsl(${h}, ${s}, ${l})`;
	else return `hsla(${h}, ${s}, ${l}, ${twoDecimals(clamp$1(color.alpha))})`;
};
const formatCss = (c$1) => {
	const color = _prepare_default(c$1);
	if (!color) return;
	const def = getMode(color.mode);
	if (!def.serialize || typeof def.serialize === "string") {
		let res = `color(${def.serialize || `--${color.mode}`} `;
		def.channels.forEach((ch, i) => {
			if (ch !== "alpha") res += (i ? " " : "") + (color[ch] !== void 0 ? color[ch] : "none");
		});
		if (color.alpha !== void 0 && color.alpha < 1) res += ` / ${color.alpha}`;
		return res + ")";
	}
	if (typeof def.serialize === "function") return def.serialize(color);
};
const formatHex = (c$1) => serializeHex(rgb$3(c$1));
const formatHex8 = (c$1) => serializeHex8(rgb$3(c$1));
const formatRgb = (c$1) => serializeRgb(rgb$3(c$1));
const formatHsl = (c$1) => serializeHsl(hsl$1(c$1));

//#endregion
//#region node_modules/culori/src/blend.js
var BLENDS = {
	normal: (b, s) => s,
	multiply: (b, s) => b * s,
	screen: (b, s) => b + s - b * s,
	"hard-light": (b, s) => s < .5 ? b * 2 * s : 2 * s * (1 - b) - 1,
	overlay: (b, s) => b < .5 ? s * 2 * b : 2 * b * (1 - s) - 1,
	darken: (b, s) => Math.min(b, s),
	lighten: (b, s) => Math.max(b, s),
	"color-dodge": (b, s) => b === 0 ? 0 : s === 1 ? 1 : Math.min(1, b / (1 - s)),
	"color-burn": (b, s) => b === 1 ? 1 : s === 0 ? 0 : 1 - Math.min(1, (1 - b) / s),
	"soft-light": (b, s) => s < .5 ? b - (1 - 2 * s) * b * (1 - b) : b + (2 * s - 1) * ((b < .25 ? ((16 * b - 12) * b + 4) * b : Math.sqrt(b)) - b),
	difference: (b, s) => Math.abs(b - s),
	exclusion: (b, s) => b + s - 2 * b * s
};
var blend = (colors, type = "normal", mode = "rgb") => {
	let fn$4 = typeof type === "function" ? type : BLENDS[type];
	let conv = converter_default(mode);
	let channels = getMode(mode).channels;
	return colors.map((c$1) => {
		let cc = conv(c$1);
		if (cc.alpha === void 0) cc.alpha = 1;
		return cc;
	}).reduce((b, s) => {
		if (b === void 0) return s;
		let alpha = s.alpha + b.alpha * (1 - s.alpha);
		return channels.reduce((res, ch) => {
			if (ch !== "alpha") if (alpha === 0) res[ch] = 0;
			else {
				res[ch] = s.alpha * (1 - b.alpha) * s[ch] + s.alpha * b.alpha * fn$4(b[ch], s[ch]) + (1 - s.alpha) * b.alpha * b[ch];
				res[ch] = Math.max(0, Math.min(1, res[ch] / alpha));
			}
			return res;
		}, {
			mode,
			alpha
		});
	});
};
var blend_default = blend;

//#endregion
//#region node_modules/culori/src/random.js
var rand = ([min$1, max]) => min$1 + Math.random() * (max - min$1);
var to_intervals = (constraints) => Object.keys(constraints).reduce((o, k$3) => {
	let v = constraints[k$3];
	o[k$3] = Array.isArray(v) ? v : [v, v];
	return o;
}, {});
var random = (mode = "rgb", constraints = {}) => {
	let def = getMode(mode);
	let limits = to_intervals(constraints);
	return def.channels.reduce((res, ch) => {
		if (limits.alpha || ch !== "alpha") res[ch] = rand(limits[ch] || def.ranges[ch]);
		return res;
	}, { mode });
};
var random_default = random;

//#endregion
//#region node_modules/culori/src/map.js
var mapper = (fn$4, mode = "rgb", preserve_mode = false) => {
	let channels = mode ? getMode(mode).channels : null;
	let conv = mode ? converter_default(mode) : _prepare_default;
	return (color) => {
		let conv_color = conv(color);
		if (!conv_color) return;
		let res = (channels || getMode(conv_color.mode).channels).reduce((res$1, ch) => {
			let v = fn$4(conv_color[ch], ch, conv_color, mode);
			if (v !== void 0 && !isNaN(v)) res$1[ch] = v;
			return res$1;
		}, { mode: conv_color.mode });
		if (!preserve_mode) return res;
		let prep = _prepare_default(color);
		if (prep && prep.mode !== res.mode) return converter_default(prep.mode)(res);
		return res;
	};
};
var mapAlphaMultiply = (v, ch, c$1) => {
	if (ch !== "alpha") return (v || 0) * (c$1.alpha !== void 0 ? c$1.alpha : 1);
	return v;
};
var mapAlphaDivide = (v, ch, c$1) => {
	if (ch !== "alpha" && c$1.alpha !== 0) return (v || 0) / (c$1.alpha !== void 0 ? c$1.alpha : 1);
	return v;
};
var mapTransferLinear = (slope = 1, intercept = 0) => (v, ch) => {
	if (ch !== "alpha") return v * slope + intercept;
	return v;
};
var mapTransferGamma = (amplitude = 1, exponent = 1, offset = 0) => (v, ch) => {
	if (ch !== "alpha") return amplitude * Math.pow(v, exponent) + offset;
	return v;
};

//#endregion
//#region node_modules/culori/src/util/normalizePositions.js
var normalizePositions = (arr) => {
	if (arr[0] === void 0) arr[0] = 0;
	if (arr[arr.length - 1] === void 0) arr[arr.length - 1] = 1;
	let i = 1;
	let j;
	let from_idx;
	let from_pos;
	let inc;
	while (i < arr.length) {
		if (arr[i] === void 0) {
			from_idx = i;
			from_pos = arr[i - 1];
			j = i;
			while (arr[j] === void 0) j++;
			inc = (arr[j] - from_pos) / (j - i + 1);
			while (i < j) {
				arr[i] = from_pos + (i + 1 - from_idx) * inc;
				i++;
			}
		} else if (arr[i] < arr[i - 1]) arr[i] = arr[i - 1];
		i++;
	}
	return arr;
};
var normalizePositions_default = normalizePositions;

//#endregion
//#region node_modules/culori/src/easing/midpoint.js
var midpoint = (H = .5) => (t) => H <= 0 ? 1 : H >= 1 ? 0 : Math.pow(t, Math.log(.5) / Math.log(H));
var midpoint_default = midpoint;

//#endregion
//#region node_modules/culori/src/interpolate/interpolate.js
var isfn = (o) => typeof o === "function";
var isobj = (o) => o && typeof o === "object";
var isnum = (o) => typeof o === "number";
var interpolate_fn = (colors, mode = "rgb", overrides, premap) => {
	let def = getMode(mode);
	let conv = converter_default(mode);
	let conv_colors = [];
	let positions = [];
	let fns = {};
	colors.forEach((val) => {
		if (Array.isArray(val)) {
			conv_colors.push(conv(val[0]));
			positions.push(val[1]);
		} else if (isnum(val) || isfn(val)) fns[positions.length] = val;
		else {
			conv_colors.push(conv(val));
			positions.push(void 0);
		}
	});
	normalizePositions_default(positions);
	let fixed = def.channels.reduce((res, ch) => {
		let ffn;
		if (isobj(overrides) && isobj(overrides[ch]) && overrides[ch].fixup) ffn = overrides[ch].fixup;
		else if (isobj(def.interpolate[ch]) && def.interpolate[ch].fixup) ffn = def.interpolate[ch].fixup;
		else ffn = (v) => v;
		res[ch] = ffn(conv_colors.map((color) => color[ch]));
		return res;
	}, {});
	if (premap) {
		let ccolors = conv_colors.map((color, idx) => {
			return def.channels.reduce((c$1, ch) => {
				c$1[ch] = fixed[ch][idx];
				return c$1;
			}, { mode });
		});
		fixed = def.channels.reduce((res, ch) => {
			res[ch] = ccolors.map((c$1) => {
				let v = premap(c$1[ch], ch, c$1, mode);
				return isNaN(v) ? void 0 : v;
			});
			return res;
		}, {});
	}
	let interpolators = def.channels.reduce((res, ch) => {
		let ifn;
		if (isfn(overrides)) ifn = overrides;
		else if (isobj(overrides) && isfn(overrides[ch])) ifn = overrides[ch];
		else if (isobj(overrides) && isobj(overrides[ch]) && overrides[ch].use) ifn = overrides[ch].use;
		else if (isfn(def.interpolate[ch])) ifn = def.interpolate[ch];
		else if (isobj(def.interpolate[ch])) ifn = def.interpolate[ch].use;
		res[ch] = ifn(fixed[ch]);
		return res;
	}, {});
	let n = conv_colors.length - 1;
	return (t) => {
		t = Math.min(Math.max(0, t), 1);
		if (t <= positions[0]) return conv_colors[0];
		if (t > positions[n]) return conv_colors[n];
		let idx = 0;
		while (positions[idx] < t) idx++;
		let start = positions[idx - 1];
		let delta = positions[idx] - start;
		let P = (t - start) / delta;
		let fn$4 = fns[idx] || fns[0];
		if (fn$4 !== void 0) {
			if (isnum(fn$4)) fn$4 = midpoint_default((fn$4 - start) / delta);
			P = fn$4(P);
		}
		let t0 = (idx - 1 + P) / n;
		return def.channels.reduce((res, channel) => {
			let val = interpolators[channel](t0);
			if (val !== void 0) res[channel] = val;
			return res;
		}, { mode });
	};
};
var interpolate = (colors, mode = "rgb", overrides) => interpolate_fn(colors, mode, overrides);
var interpolateWith = (premap, postmap) => (colors, mode = "rgb", overrides) => {
	let post = postmap ? mapper(postmap, mode) : void 0;
	let it = interpolate_fn(colors, mode, overrides, premap);
	return post ? (t) => post(it(t)) : it;
};
var interpolateWithPremultipliedAlpha = interpolateWith(mapAlphaMultiply, mapAlphaDivide);

//#endregion
//#region node_modules/culori/src/interpolate/splineBasis.js
var mod = (v, l) => (v + l) % l;
var bspline = (Vim2, Vim1, Vi, Vip1, t) => {
	let t2 = t * t;
	let t3 = t2 * t;
	return ((1 - 3 * t + 3 * t2 - t3) * Vim2 + (4 - 6 * t2 + 3 * t3) * Vim1 + (1 + 3 * t + 3 * t2 - 3 * t3) * Vi + t3 * Vip1) / 6;
};
const interpolatorSplineBasis = (arr) => (t) => {
	let classes = arr.length - 1;
	let i = t >= 1 ? classes - 1 : Math.max(0, Math.floor(t * classes));
	return bspline(i > 0 ? arr[i - 1] : 2 * arr[i] - arr[i + 1], arr[i], arr[i + 1], i < classes - 1 ? arr[i + 2] : 2 * arr[i + 1] - arr[i], (t - i / classes) * classes);
};
const interpolatorSplineBasisClosed = (arr) => (t) => {
	const classes = arr.length - 1;
	const i = Math.floor(t * classes);
	return bspline(arr[mod(i - 1, arr.length)], arr[mod(i, arr.length)], arr[mod(i + 1, arr.length)], arr[mod(i + 2, arr.length)], (t - i / classes) * classes);
};

//#endregion
//#region node_modules/culori/src/interpolate/splineNatural.js
var solve = (v) => {
	let i;
	let n = v.length - 1;
	let c$1 = new Array(n);
	let _v = new Array(n);
	let sol = new Array(n);
	c$1[1] = 1 / 4;
	_v[1] = (6 * v[1] - v[0]) / 4;
	for (i = 2; i < n; ++i) {
		c$1[i] = 1 / (4 - c$1[i - 1]);
		_v[i] = (6 * v[i] - (i == n - 1 ? v[n] : 0) - _v[i - 1]) * c$1[i];
	}
	sol[0] = v[0];
	sol[n] = v[n];
	if (n - 1 > 0) sol[n - 1] = _v[n - 1];
	for (i = n - 2; i > 0; --i) sol[i] = _v[i] - c$1[i] * sol[i + 1];
	return sol;
};
const interpolatorSplineNatural = (arr) => interpolatorSplineBasis(solve(arr));
const interpolatorSplineNaturalClosed = (arr) => interpolatorSplineBasisClosed(solve(arr));

//#endregion
//#region node_modules/culori/src/interpolate/splineMonotone.js
var sgn = Math.sign;
var min = Math.min;
var abs = Math.abs;
var mono = (arr) => {
	let n = arr.length - 1;
	let s = [];
	let p$2 = [];
	let yp = [];
	for (let i = 0; i < n; i++) {
		s.push((arr[i + 1] - arr[i]) * n);
		p$2.push(i > 0 ? .5 * (arr[i + 1] - arr[i - 1]) * n : void 0);
		yp.push(i > 0 ? (sgn(s[i - 1]) + sgn(s[i])) * min(abs(s[i - 1]), abs(s[i]), .5 * abs(p$2[i])) : void 0);
	}
	return [
		s,
		p$2,
		yp
	];
};
var interpolator = (arr, yp, s) => {
	let n = arr.length - 1;
	let n2 = n * n;
	return (t) => {
		let i;
		if (t >= 1) i = n - 1;
		else i = Math.max(0, Math.floor(t * n));
		let t1 = t - i / n;
		let t2 = t1 * t1;
		let t3 = t2 * t1;
		return (yp[i] + yp[i + 1] - 2 * s[i]) * n2 * t3 + (3 * s[i] - 2 * yp[i] - yp[i + 1]) * n * t2 + yp[i] * t1 + arr[i];
	};
};
const interpolatorSplineMonotone = (arr) => {
	if (arr.length < 3) return interpolatorLinear(arr);
	let n = arr.length - 1;
	let [s, , yp] = mono(arr);
	yp[0] = s[0];
	yp[n] = s[n - 1];
	return interpolator(arr, yp, s);
};
const interpolatorSplineMonotone2 = (arr) => {
	if (arr.length < 3) return interpolatorLinear(arr);
	let n = arr.length - 1;
	let [s, p$2, yp] = mono(arr);
	p$2[0] = (arr[1] * 2 - arr[0] * 1.5 - arr[2] * .5) * n;
	p$2[n] = (arr[n] * 1.5 - arr[n - 1] * 2 + arr[n - 2] * .5) * n;
	yp[0] = p$2[0] * s[0] <= 0 ? 0 : abs(p$2[0]) > 2 * abs(s[0]) ? 2 * s[0] : p$2[0];
	yp[n] = p$2[n] * s[n - 1] <= 0 ? 0 : abs(p$2[n]) > 2 * abs(s[n - 1]) ? 2 * s[n - 1] : p$2[n];
	return interpolator(arr, yp, s);
};
const interpolatorSplineMonotoneClosed = (arr) => {
	let n = arr.length - 1;
	let [s, p$2, yp] = mono(arr);
	p$2[0] = .5 * (arr[1] - arr[n]) * n;
	p$2[n] = .5 * (arr[0] - arr[n - 1]) * n;
	let s_m1 = (arr[0] - arr[n]) * n;
	let s_n = s_m1;
	yp[0] = (sgn(s_m1) + sgn(s[0])) * min(abs(s_m1), abs(s[0]), .5 * abs(p$2[0]));
	yp[n] = (sgn(s[n - 1]) + sgn(s_n)) * min(abs(s[n - 1]), abs(s_n), .5 * abs(p$2[n]));
	return interpolator(arr, yp, s);
};

//#endregion
//#region node_modules/culori/src/easing/gamma.js
var gamma = (γ = 1) => γ === 1 ? (t) => t : (t) => Math.pow(t, γ);
var gamma_default = gamma;

//#endregion
//#region node_modules/culori/src/samples.js
var samples = (n = 2, γ = 1) => {
	let ease = gamma_default(γ);
	if (n < 2) return n < 1 ? [] : [ease(.5)];
	let res = [];
	for (let i = 0; i < n; i++) res.push(ease(i / (n - 1)));
	return res;
};
var samples_default = samples;

//#endregion
//#region node_modules/culori/src/clamp.js
var rgb$2 = converter_default("rgb");
var fixup_rgb = (c$1) => {
	const res = {
		mode: c$1.mode,
		r: Math.max(0, Math.min(c$1.r !== void 0 ? c$1.r : 0, 1)),
		g: Math.max(0, Math.min(c$1.g !== void 0 ? c$1.g : 0, 1)),
		b: Math.max(0, Math.min(c$1.b !== void 0 ? c$1.b : 0, 1))
	};
	if (c$1.alpha !== void 0) res.alpha = c$1.alpha;
	return res;
};
var to_displayable_srgb = (c$1) => fixup_rgb(rgb$2(c$1));
var inrange_rgb = (c$1) => {
	return c$1 !== void 0 && (c$1.r === void 0 || c$1.r >= 0 && c$1.r <= 1) && (c$1.g === void 0 || c$1.g >= 0 && c$1.g <= 1) && (c$1.b === void 0 || c$1.b >= 0 && c$1.b <= 1);
};
function displayable(color) {
	return inrange_rgb(rgb$2(color));
}
function inGamut(mode = "rgb") {
	const { gamut } = getMode(mode);
	if (!gamut) return (color) => true;
	const conv = converter_default(typeof gamut === "string" ? gamut : mode);
	return (color) => inrange_rgb(conv(color));
}
function clampRgb(color) {
	color = _prepare_default(color);
	if (color === void 0 || displayable(color)) return color;
	return converter_default(color.mode)(to_displayable_srgb(color));
}
function clampGamut(mode = "rgb") {
	const { gamut } = getMode(mode);
	if (!gamut) return (color) => _prepare_default(color);
	const destMode = typeof gamut === "string" ? gamut : mode;
	const destConv = converter_default(destMode);
	const inDestGamut = inGamut(destMode);
	return (color) => {
		const original = _prepare_default(color);
		if (!original) return;
		const converted = destConv(original);
		if (inDestGamut(converted)) return original;
		const clamped = fixup_rgb(converted);
		if (original.mode === clamped.mode) return clamped;
		return converter_default(original.mode)(clamped);
	};
}
function clampChroma(color, mode = "lch", rgbGamut = "rgb") {
	color = _prepare_default(color);
	let inDestinationGamut = rgbGamut === "rgb" ? displayable : inGamut(rgbGamut);
	let clipToGamut = rgbGamut === "rgb" ? to_displayable_srgb : clampGamut(rgbGamut);
	if (color === void 0 || inDestinationGamut(color)) return color;
	let conv = converter_default(color.mode);
	color = converter_default(mode)(color);
	let clamped = {
		...color,
		c: 0
	};
	if (!inDestinationGamut(clamped)) return conv(clipToGamut(clamped));
	let start = 0;
	let end = color.c !== void 0 ? color.c : 0;
	let range = getMode(mode).ranges.c;
	let resolution = (range[1] - range[0]) / Math.pow(2, 13);
	let _last_good_c = clamped.c;
	while (end - start > resolution) {
		clamped.c = start + (end - start) * .5;
		if (inDestinationGamut(clamped)) {
			_last_good_c = clamped.c;
			start = clamped.c;
		} else end = clamped.c;
	}
	return conv(inDestinationGamut(clamped) ? clamped : {
		...clamped,
		c: _last_good_c
	});
}
function toGamut(dest = "rgb", mode = "oklch", delta = differenceEuclidean("oklch"), jnd = .02) {
	const destConv = converter_default(dest);
	const destMode = getMode(dest);
	if (!destMode.gamut) return (color) => destConv(color);
	const inDestinationGamut = inGamut(dest);
	const clipToGamut = clampGamut(dest);
	const ucs = converter_default(mode);
	const { ranges } = getMode(mode);
	if (!ranges.l || !ranges.c) throw new Error("LCH-like space expected");
	return (color) => {
		color = _prepare_default(color);
		if (color === void 0) return;
		const candidate = { ...ucs(color) };
		if (candidate.l === void 0) candidate.l = 0;
		if (candidate.c === void 0) candidate.c = 0;
		if (candidate.l >= ranges.l[1]) {
			const res = {
				...destMode.white,
				mode: dest
			};
			if (color.alpha !== void 0) res.alpha = color.alpha;
			return res;
		}
		if (candidate.l <= ranges.l[0]) {
			const res = {
				...destMode.black,
				mode: dest
			};
			if (color.alpha !== void 0) res.alpha = color.alpha;
			return res;
		}
		if (inDestinationGamut(candidate)) return destConv(candidate);
		let start = 0;
		let end = candidate.c;
		let epsilon = (ranges.c[1] - ranges.c[0]) / 4e3;
		let clipped = clipToGamut(candidate);
		while (end - start > epsilon) {
			candidate.c = (start + end) * .5;
			clipped = clipToGamut(candidate);
			if (inDestinationGamut(candidate) || delta && jnd > 0 && delta(candidate, clipped) <= jnd) start = candidate.c;
			else end = candidate.c;
		}
		return destConv(inDestinationGamut(candidate) ? candidate : clipped);
	};
}

//#endregion
//#region node_modules/culori/src/nearest.js
var nearest = (colors, metric = differenceEuclidean(), accessor = (d) => d) => {
	let arr = colors.map((c$1, idx) => ({
		color: accessor(c$1),
		i: idx
	}));
	return (color, n = 1, τ = Infinity) => {
		if (isFinite(n)) n = Math.max(1, Math.min(n, arr.length - 1));
		arr.forEach((c$1) => {
			c$1.d = metric(color, c$1.color);
		});
		return arr.sort((a, b) => a.d - b.d).slice(0, n).filter((c$1) => c$1.d < τ).map((c$1) => colors[c$1.i]);
	};
};
var nearest_default = nearest;

//#endregion
//#region node_modules/culori/src/filter.js
var minzero = (v) => Math.max(v, 0);
var clamp = (v) => Math.max(Math.min(v, 1), 0);
var lerp$1 = (a, b, t) => a === void 0 || b === void 0 ? void 0 : a + t * (b - a);
var matrixSepia = (amount) => {
	let a = 1 - clamp(amount);
	return [
		.393 + .607 * a,
		.769 - .769 * a,
		.189 - .189 * a,
		0,
		.349 - .349 * a,
		.686 + .314 * a,
		.168 - .168 * a,
		0,
		.272 - .272 * a,
		.534 - .534 * a,
		.131 + .869 * a,
		0,
		0,
		0,
		0,
		1
	];
};
var matrixSaturate = (sat) => {
	let s = minzero(sat);
	return [
		.213 + .787 * s,
		.715 - .715 * s,
		.072 - .072 * s,
		0,
		.213 - .213 * s,
		.715 + .285 * s,
		.072 - .072 * s,
		0,
		.213 - .213 * s,
		.715 - .715 * s,
		.072 + .928 * s,
		0,
		0,
		0,
		0,
		1
	];
};
var matrixGrayscale = (amount) => {
	let a = 1 - clamp(amount);
	return [
		.2126 + .7874 * a,
		.7152 - .7152 * a,
		.0722 - .0722 * a,
		0,
		.2126 - .2126 * a,
		.7152 + .2848 * a,
		.0722 - .0722 * a,
		0,
		.2126 - .2126 * a,
		.7152 - .7152 * a,
		.0722 + .9278 * a,
		0,
		0,
		0,
		0,
		1
	];
};
var matrixHueRotate = (degrees) => {
	let rad = Math.PI * degrees / 180;
	let c$1 = Math.cos(rad);
	let s = Math.sin(rad);
	return [
		.213 + c$1 * .787 - s * .213,
		.715 - c$1 * .715 - s * .715,
		.072 - c$1 * .072 + s * .928,
		0,
		.213 - c$1 * .213 + s * .143,
		.715 + c$1 * .285 + s * .14,
		.072 - c$1 * .072 - s * .283,
		0,
		.213 - c$1 * .213 - s * .787,
		.715 - c$1 * .715 + s * .715,
		.072 + c$1 * .928 + s * .072,
		0,
		0,
		0,
		0,
		1
	];
};
var matrix = (values, mode, preserve_mode = false) => {
	let conv = converter_default(mode);
	let channels = getMode(mode).channels;
	return (color) => {
		let c$1 = conv(color);
		if (!c$1) return;
		let res = { mode };
		let ch;
		let count = channels.length;
		for (let i = 0; i < values.length; i++) {
			ch = channels[Math.floor(i / count)];
			if (c$1[ch] === void 0) continue;
			res[ch] = (res[ch] || 0) + values[i] * (c$1[channels[i % count]] || 0);
		}
		if (!preserve_mode) return res;
		let prep = _prepare_default(color);
		return prep && res.mode !== prep.mode ? converter_default(prep.mode)(res) : res;
	};
};
var filterBrightness = (amt = 1, mode = "rgb") => {
	return mapper(mapTransferLinear(minzero(amt)), mode, true);
};
var filterContrast = (amt = 1, mode = "rgb") => {
	let a = minzero(amt);
	return mapper(mapTransferLinear(a, (1 - a) / 2), mode, true);
};
var filterSepia = (amt = 1, mode = "rgb") => matrix(matrixSepia(amt), mode, true);
var filterSaturate = (amt = 1, mode = "rgb") => matrix(matrixSaturate(amt), mode, true);
var filterGrayscale = (amt = 1, mode = "rgb") => matrix(matrixGrayscale(amt), mode, true);
var filterInvert = (amt = 1, mode = "rgb") => {
	let a = clamp(amt);
	return mapper((v, ch) => ch === "alpha" ? v : lerp$1(a, 1 - a, v), mode, true);
};
var filterHueRotate = (deg = 0, mode = "rgb") => matrix(matrixHueRotate(deg), mode, true);

//#endregion
//#region node_modules/culori/src/deficiency.js
var rgb$1 = converter_default("rgb");
var PROT = [
	[
		1,
		0,
		-0,
		0,
		1,
		0,
		-0,
		-0,
		1
	],
	[
		.856167,
		.182038,
		-.038205,
		.029342,
		.955115,
		.015544,
		-.00288,
		-.001563,
		1.004443
	],
	[
		.734766,
		.334872,
		-.069637,
		.05184,
		.919198,
		.028963,
		-.004928,
		-.004209,
		1.009137
	],
	[
		.630323,
		.465641,
		-.095964,
		.069181,
		.890046,
		.040773,
		-.006308,
		-.007724,
		1.014032
	],
	[
		.539009,
		.579343,
		-.118352,
		.082546,
		.866121,
		.051332,
		-.007136,
		-.011959,
		1.019095
	],
	[
		.458064,
		.679578,
		-.137642,
		.092785,
		.846313,
		.060902,
		-.007494,
		-.016807,
		1.024301
	],
	[
		.38545,
		.769005,
		-.154455,
		.100526,
		.829802,
		.069673,
		-.007442,
		-.02219,
		1.029632
	],
	[
		.319627,
		.849633,
		-.169261,
		.106241,
		.815969,
		.07779,
		-.007025,
		-.028051,
		1.035076
	],
	[
		.259411,
		.923008,
		-.18242,
		.110296,
		.80434,
		.085364,
		-.006276,
		-.034346,
		1.040622
	],
	[
		.203876,
		.990338,
		-.194214,
		.112975,
		.794542,
		.092483,
		-.005222,
		-.041043,
		1.046265
	],
	[
		.152286,
		1.052583,
		-.204868,
		.114503,
		.786281,
		.099216,
		-.003882,
		-.048116,
		1.051998
	]
];
var DEUTER = [
	[
		1,
		0,
		-0,
		0,
		1,
		0,
		-0,
		-0,
		1
	],
	[
		.866435,
		.177704,
		-.044139,
		.049567,
		.939063,
		.01137,
		-.003453,
		.007233,
		.99622
	],
	[
		.760729,
		.319078,
		-.079807,
		.090568,
		.889315,
		.020117,
		-.006027,
		.013325,
		.992702
	],
	[
		.675425,
		.43385,
		-.109275,
		.125303,
		.847755,
		.026942,
		-.00795,
		.018572,
		.989378
	],
	[
		.605511,
		.52856,
		-.134071,
		.155318,
		.812366,
		.032316,
		-.009376,
		.023176,
		.9862
	],
	[
		.547494,
		.607765,
		-.155259,
		.181692,
		.781742,
		.036566,
		-.01041,
		.027275,
		.983136
	],
	[
		.498864,
		.674741,
		-.173604,
		.205199,
		.754872,
		.039929,
		-.011131,
		.030969,
		.980162
	],
	[
		.457771,
		.731899,
		-.18967,
		.226409,
		.731012,
		.042579,
		-.011595,
		.034333,
		.977261
	],
	[
		.422823,
		.781057,
		-.203881,
		.245752,
		.709602,
		.044646,
		-.011843,
		.037423,
		.974421
	],
	[
		.392952,
		.82361,
		-.216562,
		.263559,
		.69021,
		.046232,
		-.01191,
		.040281,
		.97163
	],
	[
		.367322,
		.860646,
		-.227968,
		.280085,
		.672501,
		.047413,
		-.01182,
		.04294,
		.968881
	]
];
var TRIT = [
	[
		1,
		0,
		-0,
		0,
		1,
		0,
		-0,
		-0,
		1
	],
	[
		.92667,
		.092514,
		-.019184,
		.021191,
		.964503,
		.014306,
		.008437,
		.054813,
		.93675
	],
	[
		.89572,
		.13333,
		-.02905,
		.029997,
		.9454,
		.024603,
		.013027,
		.104707,
		.882266
	],
	[
		.905871,
		.127791,
		-.033662,
		.026856,
		.941251,
		.031893,
		.01341,
		.148296,
		.838294
	],
	[
		.948035,
		.08949,
		-.037526,
		.014364,
		.946792,
		.038844,
		.010853,
		.193991,
		.795156
	],
	[
		1.017277,
		.027029,
		-.044306,
		-.006113,
		.958479,
		.047634,
		.006379,
		.248708,
		.744913
	],
	[
		1.104996,
		-.046633,
		-.058363,
		-.032137,
		.971635,
		.060503,
		.001336,
		.317922,
		.680742
	],
	[
		1.193214,
		-.109812,
		-.083402,
		-.058496,
		.97941,
		.079086,
		-.002346,
		.403492,
		.598854
	],
	[
		1.257728,
		-.139648,
		-.118081,
		-.078003,
		.975409,
		.102594,
		-.003316,
		.501214,
		.502102
	],
	[
		1.278864,
		-.125333,
		-.153531,
		-.084748,
		.957674,
		.127074,
		-989e-6,
		.601151,
		.399838
	],
	[
		1.255528,
		-.076749,
		-.178779,
		-.078411,
		.930809,
		.147602,
		.004733,
		.691367,
		.3039
	]
];
var deficiency = (lut, t) => {
	let tt = Math.max(0, Math.min(1, t));
	let i = Math.round(tt / .1);
	let w = Math.round(tt % .1);
	let arr = lut[i];
	if (w > 0 && i < lut.length - 1) {
		let arr_2 = lut[i + 1];
		arr = arr.map((v, idx) => lerp(arr[idx], arr_2[idx], w));
	}
	return (color) => {
		let c$1 = _prepare_default(color);
		if (c$1 === void 0) return;
		let { r: r$1, g, b } = rgb$1(c$1);
		let ret = {
			mode: "rgb",
			r: arr[0] * r$1 + arr[1] * g + arr[2] * b,
			g: arr[3] * r$1 + arr[4] * g + arr[5] * b,
			b: arr[6] * r$1 + arr[7] * g + arr[8] * b
		};
		if (c$1.alpha !== void 0) ret.alpha = c$1.alpha;
		return converter_default(c$1.mode)(ret);
	};
};
const filterDeficiencyProt = (severity = 1) => deficiency(PROT, severity);
const filterDeficiencyDeuter = (severity = 1) => deficiency(DEUTER, severity);
const filterDeficiencyTrit = (severity = 1) => deficiency(TRIT, severity);

//#endregion
//#region node_modules/culori/src/easing/smoothstep.js
var easingSmoothstep = (t) => t * t * (3 - 2 * t);
var easingSmoothstepInverse = (t) => .5 - Math.sin(Math.asin(1 - 2 * t) / 3);

//#endregion
//#region node_modules/culori/src/easing/smootherstep.js
var smootherstep = (t) => t * t * t * (t * (t * 6 - 15) + 10);
var smootherstep_default = smootherstep;

//#endregion
//#region node_modules/culori/src/easing/inOutSine.js
var inOutSine = (t) => (1 - Math.cos(t * Math.PI)) / 2;
var inOutSine_default = inOutSine;

//#endregion
//#region node_modules/culori/src/wcag.js
function luminance(color) {
	let c$1 = converter_default("lrgb")(color);
	return .2126 * c$1.r + .7152 * c$1.g + .0722 * c$1.b;
}
function contrast(a, b) {
	let L1 = luminance(a);
	let L2 = luminance(b);
	return (Math.max(L1, L2) + .05) / (Math.min(L1, L2) + .05);
}

//#endregion
//#region node_modules/culori/src/index.js
const a98 = useMode(definition_default);
const cubehelix = useMode(definition_default$1);
const dlab = useMode(definition_default$2);
const dlch = useMode(definition_default$3);
const hsi = useMode(definition_default$4);
const hsl = useMode(definition_default$5);
const hsv = useMode(definition_default$6);
const hwb = useMode(definition_default$7);
const itp = useMode(definition_default$8);
const jab = useMode(definition_default$9);
const jch = useMode(definition_default$10);
const lab = useMode(definition_default$11);
const lab65 = useMode(definition_default$12);
const lch = useMode(definition_default$13);
const lch65 = useMode(definition_default$14);
const lchuv = useMode(definition_default$15);
const lrgb = useMode(definition_default$16);
const luv = useMode(definition_default$17);
const okhsl = useMode(modeOkhsl_default);
const okhsv = useMode(modeOkhsv_default);
const oklab = useMode(definition_default$18);
const oklch = useMode(definition_default$19);
const p3 = useMode(definition_default$20);
const prophoto = useMode(definition_default$21);
const rec2020 = useMode(definition_default$22);
const rgb = useMode(definition_default$23);
const xyb = useMode(definition_default$24);
const xyz50 = useMode(definition_default$25);
const xyz65 = useMode(definition_default$26);
const yiq = useMode(definition_default$27);

//#endregion
export { a98, average, averageAngle, averageNumber, blend_default as blend, blerp, clampChroma, clampGamut, clampRgb, named_default as colorsNamed, convertA98ToXyz65_default as convertA98ToXyz65, convertCubehelixToRgb_default as convertCubehelixToRgb, convertDlchToLab65_default as convertDlchToLab65, convertHsiToRgb, convertHslToRgb, convertHsvToRgb, convertHwbToRgb, convertItpToXyz65_default as convertItpToXyz65, convertJabToJch_default as convertJabToJch, convertJabToRgb_default as convertJabToRgb, convertJabToXyz65_default as convertJabToXyz65, convertJchToJab_default as convertJchToJab, convertLab65ToDlch_default as convertLab65ToDlch, convertLab65ToRgb_default as convertLab65ToRgb, convertLab65ToXyz65_default as convertLab65ToXyz65, convertLabToLch_default as convertLabToLch, convertLabToRgb_default as convertLabToRgb, convertLabToXyz50_default as convertLabToXyz50, convertLchToLab_default as convertLchToLab, convertLchuvToLuv_default as convertLchuvToLuv, convertLrgbToOklab_default as convertLrgbToOklab, convertLrgbToRgb_default as convertLrgbToRgb, convertLuvToLchuv_default as convertLuvToLchuv, convertLuvToXyz50_default as convertLuvToXyz50, convertOkhslToOklab, convertOkhsvToOklab, convertOklabToLrgb_default as convertOklabToLrgb, convertOklabToOkhsl, convertOklabToOkhsv, convertOklabToRgb_default as convertOklabToRgb, convertP3ToXyz65_default as convertP3ToXyz65, convertProphotoToXyz50_default as convertProphotoToXyz50, convertRec2020ToXyz65_default as convertRec2020ToXyz65, convertRgbToCubehelix_default as convertRgbToCubehelix, convertRgbToHsi, convertRgbToHsl, convertRgbToHsv, convertRgbToHwb, convertRgbToJab_default as convertRgbToJab, convertRgbToLab_default as convertRgbToLab, convertRgbToLab65_default as convertRgbToLab65, convertRgbToLrgb_default as convertRgbToLrgb, convertRgbToOklab_default as convertRgbToOklab, convertRgbToXyb_default as convertRgbToXyb, convertRgbToXyz50_default as convertRgbToXyz50, convertRgbToXyz65_default as convertRgbToXyz65, convertRgbToYiq_default as convertRgbToYiq, convertXybToRgb_default as convertXybToRgb, convertXyz50ToLab_default as convertXyz50ToLab, convertXyz50ToLuv_default as convertXyz50ToLuv, convertXyz50ToProphoto_default as convertXyz50ToProphoto, convertXyz50ToRgb_default as convertXyz50ToRgb, convertXyz50ToXyz65_default as convertXyz50ToXyz65, convertXyz65ToA98_default as convertXyz65ToA98, convertXyz65ToItp_default as convertXyz65ToItp, convertXyz65ToJab_default as convertXyz65ToJab, convertXyz65ToLab65_default as convertXyz65ToLab65, convertXyz65ToP3_default as convertXyz65ToP3, convertXyz65ToRec2020_default as convertXyz65ToRec2020, convertXyz65ToRgb_default as convertXyz65ToRgb, convertXyz65ToXyz50_default as convertXyz65ToXyz50, convertYiqToRgb_default as convertYiqToRgb, converter_default as converter, cubehelix, differenceCie76, differenceCie94, differenceCiede2000, differenceCmc, differenceEuclidean, differenceHueChroma, differenceHueNaive, differenceHueSaturation, differenceHyab, differenceItp, differenceKotsarenkoRamos, displayable, dlab, dlch, gamma_default as easingGamma, inOutSine_default as easingInOutSine, midpoint_default as easingMidpoint, smootherstep_default as easingSmootherstep, easingSmoothstep, easingSmoothstepInverse, filterBrightness, filterContrast, filterDeficiencyDeuter, filterDeficiencyProt, filterDeficiencyTrit, filterGrayscale, filterHueRotate, filterInvert, filterSaturate, filterSepia, fixupAlpha, fixupHueDecreasing, fixupHueIncreasing, fixupHueLonger, fixupHueShorter, formatCss, formatHex, formatHex8, formatHsl, formatRgb, getMode, hsi, hsl, hsv, hwb, inGamut, interpolate, interpolateWith, interpolateWithPremultipliedAlpha, interpolatorLinear, interpolatorPiecewise, interpolatorSplineBasis, interpolatorSplineBasisClosed, interpolatorSplineMonotone, interpolatorSplineMonotone2, interpolatorSplineMonotoneClosed, interpolatorSplineNatural, interpolatorSplineNaturalClosed, itp, jab, jch, lab, lab65, lch, lch65, lchuv, lerp, lrgb, luv, mapAlphaDivide, mapAlphaMultiply, mapTransferGamma, mapTransferLinear, mapper, definition_default as modeA98, definition_default$1 as modeCubehelix, definition_default$2 as modeDlab, definition_default$3 as modeDlch, definition_default$4 as modeHsi, definition_default$5 as modeHsl, definition_default$6 as modeHsv, definition_default$7 as modeHwb, definition_default$8 as modeItp, definition_default$9 as modeJab, definition_default$10 as modeJch, definition_default$11 as modeLab, definition_default$12 as modeLab65, definition_default$13 as modeLch, definition_default$14 as modeLch65, definition_default$15 as modeLchuv, definition_default$16 as modeLrgb, definition_default$17 as modeLuv, modeOkhsl_default as modeOkhsl, modeOkhsv_default as modeOkhsv, definition_default$18 as modeOklab, definition_default$19 as modeOklch, definition_default$20 as modeP3, definition_default$21 as modeProphoto, definition_default$22 as modeRec2020, definition_default$23 as modeRgb, definition_default$24 as modeXyb, definition_default$25 as modeXyz50, definition_default$26 as modeXyz65, definition_default$27 as modeYiq, nearest_default as nearest, okhsl, okhsv, oklab, oklch, p3, parse_default as parse, parseHex_default as parseHex, parseHsl_default as parseHsl, parseHslLegacy_default as parseHslLegacy, parseHwb_default as parseHwb, parseLab_default as parseLab, parseLch_default as parseLch, parseNamed_default as parseNamed, parseOklab_default as parseOklab, parseOklch_default as parseOklch, parseRgb_default as parseRgb, parseRgbLegacy_default as parseRgbLegacy, parseTransparent_default as parseTransparent, prophoto, random_default as random, rec2020, removeParser, rgb, round_default as round, samples_default as samples, serializeHex, serializeHex8, serializeHsl, serializeRgb, toGamut, trilerp, unlerp, useMode, useParser, contrast as wcagContrast, luminance as wcagLuminance, xyb, xyz50, xyz65, yiq };
//# sourceMappingURL=culori.js.map